import {
  getCalendarType,
  getFeature,
  getFormatSettings,
  getLanguage,
  getLocaleData,
  getLocale_default,
  getSecondaryCalendarType,
  getTimezone,
  registerFeature
} from "./chunk-GBZ2GERS.js";
import {
  __privateAdd,
  __privateMethod,
  __publicField
} from "./chunk-6WDZWUHI.js";

// node_modules/@ui5/webcomponents-base/dist/types/CalendarType.js
var CalendarType;
(function(CalendarType3) {
  CalendarType3["Gregorian"] = "Gregorian";
  CalendarType3["Islamic"] = "Islamic";
  CalendarType3["Japanese"] = "Japanese";
  CalendarType3["Buddhist"] = "Buddhist";
  CalendarType3["Persian"] = "Persian";
})(CalendarType || (CalendarType = {}));
var CalendarType_default = CalendarType;

// node_modules/@ui5/webcomponents-base/dist/config/CalendarType.js
var calendarType;
var secondaryCalendarType;
var getCalendarType2 = () => {
  if (calendarType === void 0) {
    calendarType = getCalendarType();
  }
  if (calendarType && calendarType in CalendarType_default) {
    return calendarType;
  }
  return CalendarType_default.Gregorian;
};
var getSecondaryCalendarType2 = () => {
  if (secondaryCalendarType === void 0) {
    secondaryCalendarType = getSecondaryCalendarType();
  }
  if (secondaryCalendarType && secondaryCalendarType in CalendarType_default) {
    return secondaryCalendarType;
  }
  return secondaryCalendarType;
};

// node_modules/@ui5/webcomponents-localization/dist/sap/base/Log.js
var Log = console;
Log.warning = console.warn;
var Log_default = Log;

// node_modules/@ui5/webcomponents-localization/dist/sap/base/util/ObjectPath.js
var ObjectPath = {
  set() {
  }
};
var ObjectPath_default = ObjectPath;

// node_modules/@ui5/webcomponents-localization/dist/sap/base/assert.js
var fnAssert = function(bResult, vMessage) {
  if (!bResult) {
    var sMessage = typeof vMessage === "function" ? vMessage() : vMessage;
    console.assert(bResult, sMessage);
  }
};
var assert_default = fnAssert;

// node_modules/@ui5/webcomponents-localization/dist/sap/base/util/isPlainObject.js
var class2type = {};
var hasOwn = class2type.hasOwnProperty;
var toString = class2type.toString;
var fnToString = hasOwn.toString;
var ObjectFunctionString = fnToString.call(Object);
var fnIsPlainObject = function(obj) {
  var proto, Ctor;
  if (!obj || toString.call(obj) !== "[object Object]") {
    return false;
  }
  proto = Object.getPrototypeOf(obj);
  if (!proto) {
    return true;
  }
  Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
};
var isPlainObject_default = fnIsPlainObject;

// node_modules/@ui5/webcomponents-localization/dist/sap/base/util/resolveReference.js
var resolveReference_default = function() {
  throw new Error("not implemented");
};

// node_modules/@ui5/webcomponents-localization/dist/sap/ui/base/DataType.js
var DataType = function() {
  throw new Error();
};
DataType.prototype.getName = function() {
  return void 0;
};
DataType.prototype.getBaseType = function() {
  return void 0;
};
DataType.prototype.getPrimitiveType = function() {
  var oType = this;
  while (oType.getBaseType()) {
    oType = oType.getBaseType();
  }
  return oType;
};
DataType.prototype.getComponentType = function() {
  return void 0;
};
DataType.prototype.getDefaultValue = function() {
  return void 0;
};
DataType.prototype.isArrayType = function() {
  return false;
};
DataType.prototype.isEnumType = function() {
  return false;
};
DataType.prototype.getEnumValues = function() {
  return void 0;
};
DataType.prototype.parseValue = function(sValue) {
  return sValue;
};
DataType.prototype.isValid = void 0;
DataType.prototype.setNormalizer = function(fnNormalizer) {
  assert_default(typeof fnNormalizer === "function", "DataType.setNormalizer: fnNormalizer must be a function");
  this._fnNormalizer = typeof fnNormalizer === "function" ? fnNormalizer : void 0;
};
DataType.prototype.normalize = function(oValue) {
  return this._fnNormalizer ? this._fnNormalizer(oValue) : oValue;
};
function createType(sName, mSettings, oBase) {
  mSettings = mSettings || {};
  var oBaseObject = oBase || DataType.prototype;
  var oType = Object.create(oBaseObject);
  oType.getName = function() {
    return sName;
  };
  if (mSettings.hasOwnProperty("defaultValue")) {
    var vDefault = mSettings.defaultValue;
    oType.getDefaultValue = function() {
      return vDefault;
    };
  }
  if (mSettings.isValid) {
    var fnIsValid = mSettings.isValid;
    oType.isValid = oBaseObject.isValid ? function(vValue) {
      if (!oBaseObject.isValid(vValue)) {
        return false;
      }
      return fnIsValid(vValue);
    } : fnIsValid;
  }
  if (mSettings.parseValue) {
    oType.parseValue = mSettings.parseValue;
  }
  oType.getBaseType = function() {
    return oBase;
  };
  return oType;
}
var mTypes = {
  "any": createType("any", {
    defaultValue: null,
    isValid: function(vValue) {
      return true;
    }
  }),
  "boolean": createType("boolean", {
    defaultValue: false,
    isValid: function(vValue) {
      return typeof vValue === "boolean";
    },
    parseValue: function(sValue) {
      return sValue == "true";
    }
  }),
  "int": createType("int", {
    defaultValue: 0,
    isValid: function(vValue) {
      return typeof vValue === "number" && (isNaN(vValue) || Math.floor(vValue) == vValue);
    },
    parseValue: function(sValue) {
      return parseInt(sValue);
    }
  }),
  "float": createType("float", {
    defaultValue: 0,
    isValid: function(vValue) {
      return typeof vValue === "number";
    },
    parseValue: function(sValue) {
      return parseFloat(sValue);
    }
  }),
  "string": createType("string", {
    defaultValue: "",
    isValid: function(vValue) {
      return typeof vValue === "string" || vValue instanceof String;
    },
    parseValue: function(sValue) {
      return sValue;
    }
  }),
  "object": createType("object", {
    defaultValue: null,
    isValid: function(vValue) {
      return typeof vValue === "object" || typeof vValue === "function";
    },
    parseValue: function(sValue) {
      return sValue ? JSON.parse(sValue) : null;
    }
  }),
  "function": createType("function", {
    defaultValue: null,
    isValid: function(vValue) {
      return vValue == null || typeof vValue === "function";
    },
    /*
     * Note: the second parameter <code>_oOptions</code> is a hidden feature for internal use only.
     * Its structure is subject to change. No code other than the XMLTemplateProcessor must use it.
     */
    parseValue: function(sValue, _oOptions) {
      if (sValue === "") {
        return void 0;
      }
      if (!/^\.?[A-Z_\$][A-Z0-9_\$]*(\.[A-Z_\$][A-Z0-9_\$]*)*$/i.test(sValue)) {
        throw new Error("Function references must consist of dot separated simple identifiers (A-Z, 0-9, _ or $) only, but was '" + sValue + "'");
      }
      var fnResult, oContext = _oOptions && _oOptions.context, oLocals = _oOptions && _oOptions.locals;
      fnResult = resolveReference_default(sValue, Object.assign({
        ".": oContext
      }, oLocals));
      if (fnResult && this.isValid(fnResult)) {
        return fnResult;
      }
      throw new TypeError("The string '" + sValue + "' couldn't be resolved to a function");
    }
  })
};
var arrayType = createType("array", {
  defaultValue: []
});
function createArrayType(componentType) {
  assert_default(componentType instanceof DataType, "DataType.<createArrayType>: componentType must be a DataType");
  var oType = Object.create(DataType.prototype);
  oType.getName = function() {
    return componentType.getName() + "[]";
  };
  oType.getComponentType = function() {
    return componentType;
  };
  oType.isValid = function(aValues) {
    if (aValues === null) {
      return true;
    }
    if (Array.isArray(aValues)) {
      for (var i = 0; i < aValues.length; i++) {
        if (!componentType.isValid(aValues[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  };
  oType.parseValue = function(sValue) {
    var aValues = sValue.split(",");
    for (var i = 0; i < aValues.length; i++) {
      aValues[i] = componentType.parseValue(aValues[i]);
    }
    return aValues;
  };
  oType.isArrayType = function() {
    return true;
  };
  oType.getBaseType = function() {
    return arrayType;
  };
  return oType;
}
var mEnumRegistry = /* @__PURE__ */ Object.create(null);
function createEnumType(sTypeName, oEnum) {
  var mValues = {}, sDefaultValue;
  for (var sName in oEnum) {
    var sValue = oEnum[sName];
    if (!sDefaultValue) {
      sDefaultValue = sValue;
    }
    if (typeof sValue !== "string") {
      throw new Error("Value " + sValue + " for enum type " + sTypeName + " is not a string");
    }
    if (!mValues.hasOwnProperty(sValue) || sName == sValue) {
      mValues[sValue] = sName;
    }
  }
  var oType = Object.create(DataType.prototype);
  oType.getName = function() {
    return sTypeName;
  };
  oType.isValid = function(v) {
    return typeof v === "string" && mValues.hasOwnProperty(v);
  };
  oType.parseValue = function(sValue2) {
    return oEnum[sValue2];
  };
  oType.getDefaultValue = function() {
    return sDefaultValue;
  };
  oType.getBaseType = function() {
    return mTypes.string;
  };
  oType.isEnumType = function() {
    return true;
  };
  oType.getEnumValues = function() {
    return oEnum;
  };
  return oType;
}
DataType.getType = function(sTypeName) {
  assert_default(sTypeName && typeof sTypeName === "string", "sTypeName must be a non-empty string");
  var oType = mTypes[sTypeName];
  if (!(oType instanceof DataType)) {
    if (sTypeName.indexOf("[]", sTypeName.length - 2) > 0) {
      var sComponentTypeName = sTypeName.slice(0, -2), oComponentType = this.getType(sComponentTypeName);
      oType = oComponentType && createArrayType(oComponentType);
      if (oType) {
        mTypes[sTypeName] = oType;
      }
    } else if (sTypeName !== "array") {
      oType = mEnumRegistry[sTypeName];
      if (oType == null) {
        oType = ObjectPath_default.get(sTypeName);
        if (oType != null) {
          Log_default.error(`The type '${sTypeName}' was accessed via globals. Defining enums via globals is deprecated. Please require the module 'sap/ui/base/DataType' and call the static 'DataType.registerEnum' API.`);
        }
      }
      if (oType instanceof DataType) {
        mTypes[sTypeName] = oType;
      } else if (isPlainObject_default(oType)) {
        oType = mTypes[sTypeName] = createEnumType(sTypeName, oType);
        delete mEnumRegistry[sTypeName];
      } else if (oType) {
        Log_default.warning("[FUTURE FATAL] '" + sTypeName + "' is not a valid data type. Falling back to type 'any'.");
        oType = mTypes.any;
      } else {
        Log_default.error("[FUTURE FATAL] data type '" + sTypeName + "' could not be found.");
        oType = void 0;
      }
    }
  }
  return oType;
};
DataType.createType = function(sName, mSettings, vBase) {
  assert_default(typeof sName === "string" && sName, "DataType.createType: type name must be a non-empty string");
  assert_default(vBase == null || vBase instanceof DataType || typeof vBase === "string" && vBase, "DataType.createType: base type must be empty or a DataType or a non-empty string");
  if (/[\[\]]/.test(sName)) {
    Log_default.error("[FUTURE FATAL] DataType.createType: array types ('something[]') must not be created with createType, they're created on-the-fly by DataType.getType");
  }
  if (typeof vBase === "string") {
    vBase = DataType.getType(vBase);
  }
  vBase = vBase || mTypes.any;
  if (vBase.isArrayType() || vBase.isEnumType()) {
    Log_default.error("[FUTURE FATAL] DataType.createType: base type must not be an array- or enum-type");
  }
  if (sName === "array" || mTypes[sName] instanceof DataType) {
    if (sName === "array" || mTypes[sName].getBaseType() == null) {
      throw new Error("DataType.createType: primitive or hidden type " + sName + " can't be re-defined");
    }
    Log_default.warning("[FUTURE FATAL] DataTypes.createType: type " + sName + " is redefined. This is an unsupported usage of DataType and might cause issues.");
  }
  var oType = mTypes[sName] = createType(sName, mSettings, vBase);
  return oType;
};
var oInterfaces = /* @__PURE__ */ new Set();
DataType.registerInterfaceTypes = function(aTypes) {
  aTypes.forEach(function(sType) {
    oInterfaces.add(sType);
    ObjectPath_default.set(sType, sType);
  });
};
DataType.registerEnum = function(sTypeName, mContent) {
  mEnumRegistry[sTypeName] = mContent;
};
DataType._isEnumCandidate = function(oObject) {
  return !Object.keys(oObject).some((key) => {
    const propertyType = typeof oObject[key];
    return propertyType === "object" || propertyType === "function";
  });
};
DataType.isInterfaceType = function(sType) {
  return oInterfaces.has(sType);
};
var DataType_default = DataType;

// node_modules/@ui5/webcomponents-localization/dist/sap/base/i18n/date/CalendarType.js
var CalendarType2 = {
  /**
   * The Gregorian calendar
   * @public
   */
  Gregorian: "Gregorian",
  /**
   * The Islamic calendar
   * @public
   */
  Islamic: "Islamic",
  /**
   * The Japanese emperor calendar
   * @public
   */
  Japanese: "Japanese",
  /**
   * The Persian Jalali calendar
   * @public
   */
  Persian: "Persian",
  /**
   * The Thai buddhist calendar
   * @public
   */
  Buddhist: "Buddhist"
};
var CalendarType_default2 = CalendarType2;

// node_modules/@ui5/webcomponents-localization/dist/sap/ui/core/CalendarType.js
DataType_default.registerEnum("sap.ui.core.CalendarType", CalendarType_default2);
var CalendarType_default3 = CalendarType_default2;

// node_modules/@ui5/webcomponents-localization/dist/sap/ui/core/date/_Calendars.js
var mRegistry = /* @__PURE__ */ new Map();
var _Calendars = {
  get: function(sCalendarType) {
    if (!mRegistry.has(sCalendarType)) {
      throw new Error("Required calendar type: " + sCalendarType + " not loaded.");
    }
    return mRegistry.get(sCalendarType);
  },
  set: function(sCalendarType, CalendarClass) {
    mRegistry.set(sCalendarType, CalendarClass);
  }
};
var Calendars_default = _Calendars;

// node_modules/@ui5/webcomponents-base/dist/features/LegacyDateFormats.js
var formatSettings;
var LegacyDateFormats = class {
  /**
   * Returns the currently set customizing data for Islamic calendar support
   *
   * @return {object[]} Returns an array that contains the customizing data.
   * @public
   */
  static getLegacyDateCalendarCustomizing() {
    if (formatSettings === void 0) {
      formatSettings = getFormatSettings();
    }
    return formatSettings.legacyDateCalendarCustomizing || [];
  }
};
registerFeature("LegacyDateFormats", LegacyDateFormats);
var LegacyDateFormats_default = LegacyDateFormats;

// node_modules/@ui5/webcomponents-base/dist/config/FormatSettings.js
var formatSettings2;
var getFirstDayOfWeek = () => {
  if (formatSettings2 === void 0) {
    formatSettings2 = getFormatSettings();
  }
  return formatSettings2.firstDayOfWeek;
};
var legacyDateFormats = getFeature("LegacyDateFormats");
var getLegacyDateCalendarCustomizing = legacyDateFormats ? LegacyDateFormats_default.getLegacyDateCalendarCustomizing : () => {
  return [];
};

// node_modules/@ui5/webcomponents-localization/dist/sap/ui/core/FormatSettings.js
var emptyFn = () => {
};
var FormatSettings = {
  getFormatLocale: getLocale_default,
  getLegacyDateFormat: emptyFn,
  getCustomLocaleData: emptyFn,
  getLegacyDateCalendarCustomizing
};
var FormatSettings_default = FormatSettings;

// node_modules/@ui5/webcomponents-base/dist/config/Timezone.js
var currTimezone;
var getTimezone2 = () => {
  if (currTimezone === void 0) {
    currTimezone = getTimezone();
  }
  return currTimezone;
};

// node_modules/@ui5/webcomponents-base/dist/util/getDesigntimePropertyAsArray.js
var designTimePropertyAsArray = (value) => {
  const m = /\$([-a-z0-9A-Z._]+)(?::([^$]*))?\$/.exec(value);
  return m && m[2] ? m[2].split(/,/) : null;
};
var getDesigntimePropertyAsArray_default = designTimePropertyAsArray;

// node_modules/@ui5/webcomponents-localization/dist/sap/base/i18n/date/TimezoneUtils.js
var TimezoneUtils = {};
var sLocalTimezone = "";
var aSupportedTimezoneIDs;
var oIntlDateTimeFormatCache = {
  _oCache: /* @__PURE__ */ new Map(),
  /**
   * When cache limit is reached, it gets cleared
   */
  _iCacheLimit: 10,
  /**
   * Creates or gets an instance of Intl.DateTimeFormat.
   *
   * @param {string} sTimezone IANA timezone ID
   * @returns {Intl.DateTimeFormat} Intl.DateTimeFormat instance
   */
  get: function(sTimezone) {
    var cacheEntry = this._oCache.get(sTimezone);
    if (cacheEntry) {
      return cacheEntry;
    }
    var oOptions = {
      hourCycle: "h23",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      fractionalSecondDigits: 3,
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      timeZone: sTimezone,
      timeZoneName: "short",
      era: "narrow",
      weekday: "short"
    };
    var oInstance = new Intl.DateTimeFormat("en-US", oOptions);
    if (this._oCache.size === this._iCacheLimit) {
      this._oCache = /* @__PURE__ */ new Map();
    }
    this._oCache.set(sTimezone, oInstance);
    return oInstance;
  }
};
TimezoneUtils.isValidTimezone = function(sTimezone) {
  if (!sTimezone) {
    return false;
  }
  if (Intl.supportedValuesOf) {
    try {
      aSupportedTimezoneIDs = aSupportedTimezoneIDs || Intl.supportedValuesOf("timeZone");
      if (aSupportedTimezoneIDs.includes(sTimezone)) {
        return true;
      }
    } catch (oError) {
      aSupportedTimezoneIDs = [];
    }
  }
  try {
    oIntlDateTimeFormatCache.get(sTimezone);
    return true;
  } catch (oError) {
    return false;
  }
};
TimezoneUtils.convertToTimezone = function(oDate, sTargetTimezone) {
  var oFormatParts = this._getParts(oDate, sTargetTimezone);
  return TimezoneUtils._getDateFromParts(oFormatParts);
};
TimezoneUtils._getParts = function(oDate, sTargetTimezone) {
  var sKey, oPart, oDateParts = /* @__PURE__ */ Object.create(null), oIntlDate = oIntlDateTimeFormatCache.get(sTargetTimezone), oParts = oIntlDate.formatToParts(new Date(oDate.getTime()));
  for (sKey in oParts) {
    oPart = oParts[sKey];
    if (oPart.type !== "literal") {
      oDateParts[oPart.type] = oPart.value;
    }
  }
  return oDateParts;
};
TimezoneUtils._getDateFromParts = function(oParts) {
  var oDate = /* @__PURE__ */ new Date(0), iUTCYear = parseInt(oParts.year);
  if (oParts.era === "B") {
    iUTCYear = iUTCYear * -1 + 1;
  }
  oDate.setUTCFullYear(iUTCYear, parseInt(oParts.month) - 1, parseInt(oParts.day));
  oDate.setUTCHours(parseInt(oParts.hour), parseInt(oParts.minute), parseInt(oParts.second), parseInt(oParts.fractionalSecond || 0));
  return oDate;
};
TimezoneUtils.calculateOffset = function(oDate, sTimezoneSource) {
  const oDateInTimezone = TimezoneUtils.convertToTimezone(oDate, sTimezoneSource);
  const iGivenTimestamp = oDate.getTime();
  const iInitialOffset = iGivenTimestamp - oDateInTimezone.getTime();
  const oFirstGuess = new Date(iGivenTimestamp + iInitialOffset);
  const oFirstGuessInTimezone = TimezoneUtils.convertToTimezone(oFirstGuess, sTimezoneSource);
  const iFirstGuessInTimezoneTimestamp = oFirstGuessInTimezone.getTime();
  const iSecondOffset = oFirstGuess.getTime() - iFirstGuessInTimezoneTimestamp;
  let iTimezoneOffset = iSecondOffset;
  if (iInitialOffset !== iSecondOffset) {
    const oSecondGuess = new Date(iGivenTimestamp + iSecondOffset);
    const oSecondGuessInTimezone = TimezoneUtils.convertToTimezone(oSecondGuess, sTimezoneSource);
    const iSecondGuessInTimezoneTimestamp = oSecondGuessInTimezone.getTime();
    if (iSecondGuessInTimezoneTimestamp !== iGivenTimestamp && iFirstGuessInTimezoneTimestamp > iSecondGuessInTimezoneTimestamp) {
      iTimezoneOffset = iInitialOffset;
    }
  }
  return iTimezoneOffset / 1e3;
};
TimezoneUtils.mCLDR2ABAPTimezones = {
  "America/Buenos_Aires": "America/Argentina/Buenos_Aires",
  "America/Catamarca": "America/Argentina/Catamarca",
  "America/Cordoba": "America/Argentina/Cordoba",
  "America/Jujuy": "America/Argentina/Jujuy",
  "America/Mendoza": "America/Argentina/Mendoza",
  "America/Indianapolis": "America/Indiana/Indianapolis",
  "America/Louisville": "America/Kentucky/Louisville",
  "Africa/Asmera": "Africa/Asmara",
  "Asia/Katmandu": "Asia/Kathmandu",
  "Asia/Calcutta": "Asia/Kolkata",
  "Atlantic/Faeroe": "Atlantic/Faroe",
  "Pacific/Ponape": "Pacific/Pohnpei",
  "Asia/Rangoon": "Asia/Yangon",
  "Pacific/Truk": "Pacific/Chuuk",
  "America/Godthab": "America/Nuuk",
  "Asia/Saigon": "Asia/Ho_Chi_Minh",
  "America/Coral_Harbour": "America/Atikokan"
};
TimezoneUtils.getLocalTimezone = function() {
  if (sLocalTimezone === "") {
    sLocalTimezone = new Intl.DateTimeFormat().resolvedOptions().timeZone;
    sLocalTimezone = TimezoneUtils.mCLDR2ABAPTimezones[sLocalTimezone] || sLocalTimezone;
  }
  return sLocalTimezone;
};
TimezoneUtils._clearLocalTimezoneCache = function() {
  sLocalTimezone = "";
};
var TimezoneUtils_default = TimezoneUtils;

// node_modules/@ui5/webcomponents-localization/dist/sap/ui/core/format/TimezoneUtil.js
var TimezoneUtil_default = TimezoneUtils_default;

// node_modules/@ui5/webcomponents-localization/dist/sap/ui/core/Configuration.js
var emptyFn2 = () => {
};
var Configuration = {
  getLanguage,
  getCalendarType: getCalendarType2,
  getSupportedLanguages: () => getDesigntimePropertyAsArray_default("$core-i18n-locales:,ar,bg,ca,cs,da,de,el,en,es,et,fi,fr,hi,hr,hu,it,iw,ja,ko,lt,lv,nl,no,pl,pt,ro,ru,sh,sk,sl,sv,th,tr,uk,vi,zh_CN,zh_TW$"),
  getOriginInfo: emptyFn2,
  getFormatSettings: () => FormatSettings_default,
  getTimezone: () => getTimezone2() || TimezoneUtil_default.getLocalTimezone(),
  // Calculate calendar week numbering by active format locale
  getCalendarWeekNumbering: () => "Default"
};
var Configuration_default = Configuration;

// node_modules/@ui5/webcomponents-localization/dist/sap/ui/core/Core.js
var emptyFn3 = () => {
};
var Core = {
  getConfiguration: () => Configuration_default,
  getLibraryResourceBundle: emptyFn3(),
  getFormatSettings: () => FormatSettings_default
};
var Core_default = Core;

// node_modules/@ui5/webcomponents-localization/dist/sap/base/util/array/uniqueSort.js
var fnUniqueSort = function(aArray) {
  assert_default(Array.isArray(aArray), "uniqueSort: input parameter must be an Array");
  var iLength = aArray.length;
  if (iLength > 1) {
    aArray.sort();
    var j = 0;
    for (var i = 1; i < iLength; i++) {
      if (aArray.indexOf(aArray[i]) === i) {
        aArray[++j] = aArray[i];
      }
    }
    if (++j < iLength) {
      aArray.splice(j, iLength - j);
    }
  }
  return aArray;
};
var uniqueSort_default = fnUniqueSort;

// node_modules/@ui5/webcomponents-localization/dist/sap/ui/base/Metadata.js
function isFunction(obj) {
  return typeof obj === "function";
}
var Metadata = function(sClassName, oClassInfo) {
  assert_default(typeof sClassName === "string" && sClassName, "Metadata: sClassName must be a non-empty string");
  assert_default(typeof oClassInfo === "object", "Metadata: oClassInfo must be empty or an object");
  if (!oClassInfo || typeof oClassInfo.metadata !== "object") {
    oClassInfo = {
      metadata: oClassInfo || {},
      // retrieve class by its name. Using a lookup costs time but avoids the need for redundant arguments to this function
      constructor: ObjectPath_default.get(sClassName)
      // legacy-relevant, code path not used by extend call
    };
    oClassInfo.metadata.__version = 1;
  }
  oClassInfo.metadata.__version = oClassInfo.metadata.__version || 2;
  if (!isFunction(oClassInfo.constructor)) {
    throw Error("constructor for class " + sClassName + " must have been declared before creating metadata for it");
  }
  this._sClassName = sClassName;
  this._oClass = oClassInfo.constructor;
  this.extend(oClassInfo);
};
Metadata.prototype.extend = function(oClassInfo) {
  this.applySettings(oClassInfo);
  this.afterApplySettings();
};
Metadata.prototype.applySettings = function(oClassInfo) {
  var that = this, oStaticInfo = oClassInfo.metadata, oPrototype;
  if (oStaticInfo.baseType) {
    var oParentClass;
    if (isFunction(oStaticInfo.baseType)) {
      oParentClass = oStaticInfo.baseType;
      if (!isFunction(oParentClass.getMetadata)) {
        throw new TypeError("baseType must be a UI5 class with a static getMetadata function");
      }
    } else {
      oParentClass = ObjectPath_default.get(oStaticInfo.baseType);
      if (!isFunction(oParentClass)) {
        Log_default.fatal("base class '" + oStaticInfo.baseType + "' does not exist");
      }
    }
    if (oParentClass.getMetadata) {
      this._oParent = oParentClass.getMetadata();
      assert_default(oParentClass === oParentClass.getMetadata().getClass(), "Metadata: oParentClass must match the class in the parent metadata");
    } else {
      this._oParent = new Metadata(oStaticInfo.baseType, {});
    }
  } else {
    this._oParent = void 0;
  }
  this._bAbstract = !!oStaticInfo["abstract"];
  this._bFinal = !!oStaticInfo["final"];
  this._sStereotype = oStaticInfo.stereotype || (this._oParent ? this._oParent._sStereotype : "object");
  this._bDeprecated = !!oStaticInfo["deprecated"];
  this._aInterfaces = oStaticInfo.interfaces || [];
  this._aPublicMethods = oStaticInfo.publicMethods || [];
  this._bInterfacesUnique = false;
  oPrototype = this._oClass.prototype;
  for (var n in oClassInfo) {
    if (n !== "metadata" && n !== "constructor") {
      oPrototype[n] = oClassInfo[n];
      if (!n.match(/^_|^on|^init$|^exit$/)) {
        that._aPublicMethods.push(n);
      }
    }
  }
};
Metadata.prototype.afterApplySettings = function() {
  if (this._oParent) {
    this._aAllPublicMethods = this._oParent._aAllPublicMethods.concat(this._aPublicMethods);
    this._bInterfacesUnique = false;
  } else {
    this._aAllPublicMethods = this._aPublicMethods;
  }
};
Metadata.prototype.getStereotype = function() {
  return this._sStereotype;
};
Metadata.prototype.getName = function() {
  return this._sClassName;
};
Metadata.prototype.getClass = function() {
  return this._oClass;
};
Metadata.prototype.getParent = function() {
  return this._oParent;
};
Metadata.prototype._dedupInterfaces = function() {
  if (!this._bInterfacesUnique) {
    uniqueSort_default(this._aInterfaces);
    uniqueSort_default(this._aPublicMethods);
    uniqueSort_default(this._aAllPublicMethods);
    this._bInterfacesUnique = true;
  }
};
Metadata.prototype.getPublicMethods = function() {
  this._dedupInterfaces();
  return this._aPublicMethods;
};
Metadata.prototype.getAllPublicMethods = function() {
  this._dedupInterfaces();
  return this._aAllPublicMethods;
};
Metadata.prototype.getInterfaces = function() {
  this._dedupInterfaces();
  return this._aInterfaces;
};
Metadata.prototype.isInstanceOf = function(sInterface) {
  if (this._oParent) {
    if (this._oParent.isInstanceOf(sInterface)) {
      return true;
    }
  }
  var a = this._aInterfaces;
  for (var i = 0, l = a.length; i < l; i++) {
    if (a[i] === sInterface) {
      return true;
    }
  }
  return false;
};
Object.defineProperty(Metadata.prototype, "_mImplementedTypes", {
  get: function() {
    if (this === Metadata.prototype) {
      throw new Error("sap.ui.base.Metadata: The '_mImplementedTypes' property must not be accessed on the prototype");
    }
    var result = Object.create(this._oParent ? this._oParent._mImplementedTypes : null);
    result[this._sClassName] = true;
    var aInterfaces = this._aInterfaces, i = aInterfaces.length;
    while (i-- > 0) {
      if (!result[aInterfaces[i]]) {
        result[aInterfaces[i]] = true;
      }
    }
    Object.defineProperty(this, "_mImplementedTypes", {
      value: Object.freeze(result),
      writable: false,
      configurable: false
    });
    return result;
  },
  configurable: true
});
Metadata.prototype.isA = function(vTypeName) {
  var mTypes2 = this._mImplementedTypes;
  if (Array.isArray(vTypeName)) {
    for (var i = 0; i < vTypeName.length; i++) {
      if (vTypeName[i] in mTypes2) {
        return true;
      }
    }
    return false;
  }
  return vTypeName in mTypes2;
};
Metadata.prototype.isAbstract = function() {
  return this._bAbstract;
};
Metadata.prototype.isFinal = function() {
  return this._bFinal;
};
Metadata.prototype.isDeprecated = function() {
  return this._bDeprecated;
};
Metadata.prototype.addPublicMethods = function(sMethod) {
  var aNames = sMethod instanceof Array ? sMethod : arguments;
  Array.prototype.push.apply(this._aPublicMethods, aNames);
  Array.prototype.push.apply(this._aAllPublicMethods, aNames);
  this._bInterfacesUnique = false;
};
Metadata.createClass = function(fnBaseClass, sClassName, oClassInfo, FNMetaImpl) {
  if (typeof fnBaseClass === "string") {
    FNMetaImpl = oClassInfo;
    oClassInfo = sClassName;
    sClassName = fnBaseClass;
    fnBaseClass = null;
  }
  assert_default(!fnBaseClass || isFunction(fnBaseClass));
  assert_default(typeof sClassName === "string" && !!sClassName);
  assert_default(!oClassInfo || typeof oClassInfo === "object");
  assert_default(!FNMetaImpl || isFunction(FNMetaImpl));
  FNMetaImpl = FNMetaImpl || Metadata;
  if (isFunction(FNMetaImpl.preprocessClassInfo)) {
    oClassInfo = FNMetaImpl.preprocessClassInfo(oClassInfo);
  }
  oClassInfo = oClassInfo || {};
  oClassInfo.metadata = oClassInfo.metadata || {};
  if (!oClassInfo.hasOwnProperty("constructor")) {
    oClassInfo.constructor = void 0;
  }
  var fnClass = oClassInfo.constructor;
  assert_default(!fnClass || isFunction(fnClass));
  if (fnBaseClass) {
    if (!fnClass) {
      if (oClassInfo.metadata.deprecated) {
        fnClass = function() {
          Log_default.warning("Usage of deprecated class: " + sClassName);
          fnBaseClass.apply(this, arguments);
        };
      } else {
        fnClass = function() {
          fnBaseClass.apply(this, arguments);
        };
      }
    }
    fnClass.prototype = Object.create(fnBaseClass.prototype);
    fnClass.prototype.constructor = fnClass;
    oClassInfo.metadata.baseType = fnBaseClass;
  } else {
    fnClass = fnClass || function() {
    };
    delete oClassInfo.metadata.baseType;
  }
  oClassInfo.constructor = fnClass;
  ObjectPath_default.set(sClassName, fnClass);
  var oMetadata = new FNMetaImpl(sClassName, oClassInfo);
  fnClass.getMetadata = fnClass.prototype.getMetadata = function() {
    return oMetadata;
  };
  if (!fnClass.getMetadata().isFinal()) {
    fnClass.extend = function(sSCName, oSCClassInfo, fnSCMetaImpl) {
      return Metadata.createClass(fnClass, sSCName, oSCClassInfo, fnSCMetaImpl || FNMetaImpl);
    };
  }
  return fnClass;
};
var Metadata_default = Metadata;

// node_modules/@ui5/webcomponents-localization/dist/sap/ui/base/Object.js
var BaseObject = Metadata_default.createClass("sap.ui.base.Object", {
  constructor: function() {
    if (!(this instanceof BaseObject)) {
      throw Error('Cannot instantiate object: "new" is missing!');
    }
  }
});
BaseObject.prototype.destroy = function() {
};
BaseObject.prototype.getInterface = function() {
  var oInterface = new BaseObject._Interface(this, this.getMetadata().getAllPublicMethods());
  this.getInterface = function() {
    return oInterface;
  };
  return oInterface;
};
BaseObject.defineClass = function(sClassName, oStaticInfo, FNMetaImpl) {
  var oMetadata = new (FNMetaImpl || Metadata_default)(sClassName, oStaticInfo);
  var fnClass = oMetadata.getClass();
  fnClass.getMetadata = fnClass.prototype.getMetadata = function() {
    return oMetadata;
  };
  if (!oMetadata.isFinal()) {
    fnClass.extend = function(sSCName, oSCClassInfo, fnSCMetaImpl) {
      return Metadata_default.createClass(fnClass, sSCName, oSCClassInfo, fnSCMetaImpl || FNMetaImpl);
    };
  }
  Log_default.debug("defined class '" + sClassName + "'" + (oMetadata.getParent() ? " as subclass of " + oMetadata.getParent().getName() : ""));
  return oMetadata;
};
BaseObject.prototype.isA = function(vTypeName) {
  return this.getMetadata().isA(vTypeName);
};
BaseObject.isA = function(oObject, vTypeName) {
  return oObject instanceof BaseObject && oObject.isA(vTypeName);
};
BaseObject.isObjectA = function(oObject, vTypeName) {
  return oObject instanceof BaseObject && oObject.isA(vTypeName);
};
BaseObject._Interface = function(oObject, aMethods, _bReturnFacade) {
  if (!oObject) {
    return oObject;
  }
  function fCreateDelegator(oObject2, sMethodName2) {
    return function() {
      var tmp = oObject2[sMethodName2].apply(oObject2, arguments);
      if (_bReturnFacade) {
        return this;
      } else {
        return tmp instanceof BaseObject ? tmp.getInterface() : tmp;
      }
    };
  }
  if (!aMethods) {
    return {};
  }
  var sMethodName;
  for (var i = 0, ml = aMethods.length; i < ml; i++) {
    sMethodName = aMethods[i];
    if (!oObject[sMethodName] || typeof oObject[sMethodName] === "function") {
      this[sMethodName] = fCreateDelegator(oObject, sMethodName);
    }
  }
};
var Object_default = BaseObject;

// node_modules/@ui5/webcomponents-localization/dist/sap/base/i18n/Localization.js
var M_ISO639_OLD_TO_NEW = {
  "iw": "he",
  "ji": "yi"
};
var getModernLanguage = (sLanguage) => {
  return M_ISO639_OLD_TO_NEW[sLanguage] || sLanguage;
};
var Localization = {
  getModernLanguage
};
var Localization_default = Localization;

// node_modules/@ui5/webcomponents-localization/dist/sap/base/i18n/LanguageTag.js
var rLanguageTag = /^((?:[A-Z]{2,3}(?:-[A-Z]{3}){0,3})|[A-Z]{4}|[A-Z]{5,8})(?:-([A-Z]{4}))?(?:-([A-Z]{2}|[0-9]{3}))?((?:-[0-9A-Z]{5,8}|-[0-9][0-9A-Z]{3})*)((?:-[0-9A-WYZ](?:-[0-9A-Z]{2,8})+)*)(?:-(X(?:-[0-9A-Z]{1,8})+))?$/i;
var _join, join_fn;
var LanguageTag = class {
  constructor(sLanguageTag) {
    __privateAdd(this, _join);
    /**
     * Get the language.
     *
     * Note that the case might differ from the original script tag
     * (Lower case is enforced as recommended by BCP47/ISO639).
     *
     * @type {string}
     * @public
     */
    __publicField(this, "language");
    /**
     * Get the script or <code>null</code> if none was specified.
     *
     * Note that the case might differ from the original language tag
     * (Upper case first letter and lower case reminder enforced as
     * recommended by BCP47/ISO15924)
     *
     * @type {string|null}
     * @public
     */
    __publicField(this, "script");
    /**
     * Get the region or <code>null</code> if none was specified.
     *
     * Note that the case might differ from the original script tag
     * (Upper case is enforced as recommended by BCP47/ISO3166-1).
     *
     * @type {string}
     * @public
     */
    __publicField(this, "region");
    /**
     * Get the variants as a single string or <code>null</code>.
     *
     * Multiple variants are separated by a dash '-'.
     *
     * @type {string|null}
     * @public
     */
    __publicField(this, "variant");
    /**
     * Get the variants as an array of individual variants.
     *
     * The separating dashes are not part of the result.
     * If there is no variant section in the language tag, an empty array is returned.
     *
     * @type {string[]}
     * @public
     */
    __publicField(this, "variantSubtags");
    /**
     * Get the extension as a single string or <code>null</code>.
     *
     * The extension always consists of a singleton character (not 'x'),
     * a dash '-' and one or more extension token, each separated
     * again with a dash.
     *
     * @type {string|null}
     * @public
     */
    __publicField(this, "extension");
    /**
     * Get the extensions as an array of tokens.
     *
     * The leading singleton and the separating dashes are not part of the result.
     * If there is no extensions section in the language tag, an empty array is returned.
     *
     * @type {string[]}
     * @public
     */
    __publicField(this, "extensionSubtags");
    /**
     * Get the private use section or <code>null</code>.
     *
     * @type {string}
     */
    __publicField(this, "privateUse");
    /**
     * Get the private use section as an array of tokens.
     *
     * The leading singleton and the separating dashes are not part of the result.
     * If there is no private use section in the language tag, an empty array is returned.
     *
     * @type {string[]}
     */
    __publicField(this, "privateUseSubtags");
    var aResult = rLanguageTag.exec(sLanguageTag.replace(/_/g, "-"));
    if (aResult === null) {
      throw new TypeError("The given language tag'" + sLanguageTag + "' does not adhere to BCP-47.");
    }
    this.language = aResult[1] || null;
    this.script = aResult[2] || null;
    this.region = aResult[3] || null;
    this.variant = aResult[4] && aResult[4].slice(1) || null;
    this.variantSubtags = this.variant ? this.variant.split("-") : [];
    this.extension = aResult[5] && aResult[5].slice(1) || null;
    this.extensionSubtags = this.variant ? this.variant.split("-") : [];
    this.privateUse = aResult[6] || null;
    this.privateUseSubtags = this.privateUse ? this.privateUse.slice(2).split("-") : [];
    if (this.language) {
      this.language = this.language.toLowerCase();
    }
    if (this.script) {
      this.script = this.script.toLowerCase().replace(/^[a-z]/, function($) {
        return $.toUpperCase();
      });
    }
    if (this.region) {
      this.region = this.region.toUpperCase();
    }
    Object.freeze(this);
  }
  toString() {
    return __privateMethod(this, _join, join_fn).call(this, this.language, this.script, this.region, this.variant, this.extension, this.privateUse);
  }
};
_join = new WeakSet();
join_fn = function() {
  return Array.prototype.filter.call(arguments, Boolean).join("-");
};
var LanguageTag_default = LanguageTag;

// node_modules/@ui5/webcomponents-localization/dist/sap/ui/core/Locale.js
var mCache = /* @__PURE__ */ Object.create(null);
var Locale = Object_default.extend(
  "sap.ui.core.Locale",
  /** @lends sap.ui.core.Locale.prototype */
  {
    constructor: function(vLocale) {
      Object_default.apply(this);
      if (vLocale instanceof LanguageTag_default) {
        this.oLanguageTag = vLocale;
        this.sLocaleId = this.oLanguageTag.toString();
      } else {
        this.oLanguageTag = new LanguageTag_default(vLocale);
        this.sLocaleId = vLocale;
      }
      Object.assign(this, this.oLanguageTag);
      this.sLanguage = this.language;
    },
    /**
     * Get the locale language.
     *
     * Note that the case might differ from the original script tag
     * (Lower case is enforced as recommended by BCP47/ISO639).
     *
     * @returns {string} the language code
     * @public
     */
    getLanguage: function() {
      return this.language;
    },
    /**
     * Get the locale script or <code>null</code> if none was specified.
     *
     * Note that the case might differ from the original language tag
     * (Upper case first letter and lower case reminder enforced as
     * recommended by BCP47/ISO15924)
     *
     * @returns {string|null} the script code or <code>null</code>
     * @public
     */
    getScript: function() {
      return this.script;
    },
    /**
     * Get the locale region or <code>null</code> if none was specified.
     *
     * Note that the case might differ from the original script tag
     * (Upper case is enforced as recommended by BCP47/ISO3166-1).
     *
     * @returns {string} the ISO3166-1 region code (2-letter or 3-digits)
     * @public
     */
    getRegion: function() {
      return this.region;
    },
    /**
     * Get the locale variants as a single string or <code>null</code>.
     *
     * Multiple variants are separated by a dash '-'.
     *
     * @returns {string|null} the variant or <code>null</code>
     * @public
     */
    getVariant: function() {
      return this.variant;
    },
    /**
     * Get the locale variants as an array of individual variants.
     *
     * The separating dashes are not part of the result.
     * If there is no variant section in the locale tag, an empty array is returned.
     *
     * @returns {string[]} the individual variant sections
     * @public
     */
    getVariantSubtags: function() {
      return this.variantSubtags;
    },
    /**
     * Get the locale extension as a single string or <code>null</code>.
     *
     * The extension always consists of a singleton character (not 'x'),
     * a dash '-' and one or more extension token, each separated
     * again with a dash.
     *
     * Use {@link #getExtensions} to get the individual extension tokens as an array.
     *
     * @returns {string|null} the extension or <code>null</code>
     * @public
     */
    getExtension: function() {
      return this.extension;
    },
    /**
     * Get the locale extensions as an array of tokens.
     *
     * The leading singleton and the separating dashes are not part of the result.
     * If there is no extensions section in the locale tag, an empty array is returned.
     *
     * @returns {string[]} the individual extension sections
     * @public
     */
    getExtensionSubtags: function() {
      return this.extensionSubtags;
    },
    /**
     * Get the locale private use section or <code>null</code>.
     *
     * @returns {string} the private use section
     * @public
     */
    getPrivateUse: function() {
      return this.privateUse;
    },
    /**
     * Get the locale private use section as an array of tokens.
     *
     * The leading singleton and the separating dashes are not part of the result.
     * If there is no private use section in the locale tag, an empty array is returned.
     *
     * @returns {string[]} the tokens of the private use section
     * @public
     */
    getPrivateUseSubtags: function() {
      return this.privateUseSubtags;
    },
    /**
     * Check if a subtag is provided
     *
     * @param {string} sSubtag The subtag to check
     * @returns {boolean} Wether the subtag is provided or not
     */
    hasPrivateUseSubtag: function(sSubtag) {
      assert_default(sSubtag && sSubtag.match(/^[0-9A-Z]{1,8}$/i), "subtag must be a valid BCP47 private use tag");
      return this.privateUseSubtags.indexOf(sSubtag) >= 0;
    },
    toString: function() {
      return this.oLanguageTag.toString();
    },
    /**
     * Best guess to get a proper SAP Logon Language for this locale.
     *
     * Conversions taken into account:
     * <ul>
     * <li>use the language part only</li>
     * <li>convert old ISO639 codes to newer ones (e.g. 'iw' to 'he')</li>
     * <li>for Chinese, map 'Traditional Chinese' or region 'TW' to SAP proprietary code 'zf'</li>
     * <li>map private extensions x-saptrc, x-sappsd and saprigi to SAP pseudo languages '1Q', '2Q' and '3Q'</li>
     * <li>remove ext. language sub tags</li>
     * <li>convert to uppercase</li>
     * </ul>
     *
     * Note that the conversion also returns a result for languages that are not
     * supported by the default set of SAP languages. This method has no knowledge
     * about the concrete languages of any given backend system.
     *
     * @returns {string} a language code that should
     * @public
     * @since 1.17.0
     * @deprecated As of 1.44, use {@link sap.ui.core.Configuration#getSAPLogonLanguage} instead
     *   as that class allows to configure an SAP Logon language.
     */
    getSAPLogonLanguage: function() {
      return Localization_default._getSAPLogonLanguage(this);
    }
  }
);
Locale._getCoreLocale = function(oLocale) {
  if (oLocale instanceof LanguageTag_default) {
    oLocale = mCache[oLocale.toString()] || new Locale(oLocale);
    mCache[oLocale.toString()] = oLocale;
  }
  return oLocale;
};
var Locale_default = Locale;

// node_modules/@ui5/webcomponents-localization/dist/sap/base/util/_merge.js
var oToken = /* @__PURE__ */ Object.create(null);
var fnMerge = function() {
  var src, copyIsArray, copy, name, options, clone, target = arguments[2] || {}, i = 3, length = arguments.length, deep = arguments[0] || false, skipToken = arguments[1] ? void 0 : oToken;
  if (typeof target !== "object" && typeof target !== "function") {
    target = {};
  }
  for (; i < length; i++) {
    if ((options = arguments[i]) != null) {
      for (name in options) {
        src = target[name];
        copy = options[name];
        if (name === "__proto__" || target === copy) {
          continue;
        }
        if (deep && copy && (isPlainObject_default(copy) || (copyIsArray = Array.isArray(copy)))) {
          if (copyIsArray) {
            copyIsArray = false;
            clone = src && Array.isArray(src) ? src : [];
          } else {
            clone = src && isPlainObject_default(src) ? src : {};
          }
          target[name] = fnMerge(deep, arguments[1], clone, copy);
        } else if (copy !== skipToken) {
          target[name] = copy;
        }
      }
    }
  }
  return target;
};
var merge_default = fnMerge;

// node_modules/@ui5/webcomponents-localization/dist/sap/base/util/extend.js
var fnExtend = function() {
  var args = [false, true];
  args.push.apply(args, arguments);
  return merge_default.apply(null, args);
};
var extend_default = fnExtend;

// node_modules/@ui5/webcomponents-localization/dist/sap/base/util/LoaderExtensions.js
var loadResource = (moduleName) => {
  const moduleFormat = moduleName.match(/sap\/ui\/core\/cldr\/(\w+)\.json/);
  if (!moduleFormat) {
    throw new Error(`Unknown module "${moduleName}"`);
  }
  const localeId = moduleFormat[1];
  return getLocaleData(localeId);
};
var LoaderExtensions = {
  loadResource
};
var LoaderExtensions_default = LoaderExtensions;

// node_modules/@ui5/webcomponents-localization/dist/sap/base/i18n/date/CalendarWeekNumbering.js
var CalendarWeekNumbering = {
  /**
   * The default calendar week numbering:
   *
   * The framework determines the week numbering scheme; currently it is derived from the
   * active format locale. Future versions of UI5 might select a different week numbering
   * scheme.
   *
   * @public
   */
  Default: "Default",
  /**
   * Official calendar week numbering in most of Europe (ISO 8601 standard):
   * <ul>
   * <li>Monday is first day of the week,
   * <li>the week containing January 4th is first week of the year.
   * </ul>
   *
   * @public
   */
  ISO_8601: "ISO_8601",
  /**
   * Official calendar week numbering in much of the Middle East (Middle Eastern calendar):
   * <ul>
   * <li>Saturday is first day of the week,
   * <li>the week containing January 1st is first week of the year.
   * </ul>
   *
   * @public
   */
  MiddleEastern: "MiddleEastern",
  /**
   * Official calendar week numbering in the United States, Canada, Brazil, Israel, Japan, and
   * other countries (Western traditional calendar):
   * <ul>
   * <li>Sunday is first day of the week,
   * <li>the week containing January 1st is first week of the year.
   * </ul>
   *
   * @public
   */
  WesternTraditional: "WesternTraditional"
};
Object.defineProperty(CalendarWeekNumbering, "getWeekConfigurationValues", {
  // configurable : false,
  // enumerable : false,
  value: function(sCalendarWeekNumbering) {
    switch (sCalendarWeekNumbering) {
      case CalendarWeekNumbering.ISO_8601:
        return {
          firstDayOfWeek: 1,
          minimalDaysInFirstWeek: 4
        };
      case CalendarWeekNumbering.MiddleEastern:
        return {
          firstDayOfWeek: 6,
          minimalDaysInFirstWeek: 1
        };
      case CalendarWeekNumbering.WesternTraditional:
        return {
          firstDayOfWeek: 0,
          minimalDaysInFirstWeek: 1
        };
      default:
        return void 0;
    }
  }
  // writable : false
});
var CalendarWeekNumbering_default = CalendarWeekNumbering;

// node_modules/@ui5/webcomponents-localization/dist/sap/ui/core/date/CalendarWeekNumbering.js
DataType_default.registerEnum("sap.ui.core.date.CalendarWeekNumbering", CalendarWeekNumbering_default);
var CalendarWeekNumbering_default2 = CalendarWeekNumbering_default;

// node_modules/@ui5/webcomponents-localization/dist/sap/ui/core/LocaleData.js
var rCIgnoreCase = /c/i;
var rEIgnoreCase = /e/i;
var mLegacyUnit2CurrentUnit = {
  "acceleration-meter-per-second-squared": "acceleration-meter-per-square-second",
  "concentr-milligram-per-deciliter": "concentr-milligram-ofglucose-per-deciliter",
  "concentr-part-per-million": "concentr-permillion",
  "consumption-liter-per-100kilometers": "consumption-liter-per-100-kilometer",
  "mass-metric-ton": "mass-tonne",
  "pressure-millimeter-of-mercury": "pressure-millimeter-ofhg",
  "pressure-pound-per-square-inch": "pressure-pound-force-per-square-inch",
  "pressure-inch-hg": "pressure-inch-ofhg",
  "torque-pound-foot": "torque-pound-force-foot"
};
var rNumberInScientificNotation = /^([+-]?)((\d+)(?:\.(\d+))?)[eE]([+-]?\d+)$/;
var rTrailingZeroes = /0+$/;
var rFallbackPatternTextParts = /(.*)?\{[0|1]}(.*)?\{[0|1]}(.*)?/;
var aSupportedWidths = ["narrow", "abbreviated", "wide"];
var LocaleData = Object_default.extend(
  "sap.ui.core.LocaleData",
  /** @lends sap.ui.core.LocaleData.prototype */
  {
    constructor: function(oLocale) {
      Object_default.apply(this);
      this.oLocale = Locale_default._getCoreLocale(oLocale);
      var oDataLoaded = getData(this.oLocale);
      this.mData = oDataLoaded.mData;
      this.sCLDRLocaleId = oDataLoaded.sCLDRLocaleId;
    },
    /**
     * @private
     * @ui5-restricted UI5 Web Components
     */
    _get: function() {
      return this._getDeep(this.mData, arguments);
    },
    /**
     * Retrieves merged object if overlay data is available
     * @private
     * @return {object} merged object
     */
    _getMerged: function() {
      return this._get.apply(this, arguments);
    },
    /**
     * Get month names in width "narrow", "abbreviated" or "wide". Result may contain alternative month names.
     *
     * @param {"narrow"|"abbreviated"|"wide"} sWidth
     *   The required width for the month names
     * @param {sap.ui.core.CalendarType} [sCalendarType]
     *   The type of calendar; defaults to the calendar type either set in configuration or calculated from locale
     * @returns {array}
     *   The array of month names; if no alternative exists the entry for the month is its name as a string; if
     *   there are alternative month names the entry for the month is an array of strings with the alternative names
     * @private
     */
    _getMonthsWithAlternatives: function(sWidth, sCalendarType) {
      return this._get(getCLDRCalendarName(sCalendarType), "months", "format", sWidth);
    },
    /**
     * Get standalone month names in width "narrow", "abbreviated" or "wide". Result may contain alternative month
     * names.
     *
     * @param {"narrow"|"abbreviated"|"wide"} sWidth
     *   The required width for the month names
     * @param {sap.ui.core.CalendarType} [sCalendarType]
     *   The type of calendar; defaults to the calendar type either set in configuration or calculated from locale
     * @returns {array}
     *   The array of month names; if no alternative exists the entry for the month is its name as a string; if
     *   there are alternative month names the entry for the month is an array of strings with the alternative names
     * @private
     */
    _getMonthsStandAloneWithAlternatives: function(sWidth, sCalendarType) {
      return this._get(getCLDRCalendarName(sCalendarType), "months", "stand-alone", sWidth);
    },
    _getDeep: function(oObject, aPropertyNames) {
      var oResult = oObject;
      for (var i = 0; i < aPropertyNames.length; i++) {
        oResult = oResult[aPropertyNames[i]];
        if (oResult === void 0) {
          break;
        }
      }
      return oResult;
    },
    /**
     * Get orientation (left-to-right or right-to-left).
     *
     * @returns {string} character orientation for this locale
     * @public
     */
    getOrientation: function() {
      return this._get("orientation");
    },
    /**
     * Get a display name for the language of the Locale of this LocaleData, using
     * the CLDR display names for languages.
     *
     * The lookup logic works as follows:
     * 1. language code and region is checked (e.g. "en-GB")
     * 2. If not found: language code and script is checked (e.g. "zh-Hant")
     * 3. If not found language code is checked (e.g. "en")
     * 4. If it is then still not found <code>undefined</code> is returned.
     *
     * @returns {string} language name, e.g. "English", "British English", "American English"
     *  or <code>undefined</code> if language cannot be found
     * @private
     * @ui5-restricted sap.ushell
     */
    getCurrentLanguageName: function() {
      return this.getLanguageName(this.oLocale.toString());
    },
    /**
     * Gets the locale-specific language name for the given language tag.
     *
     * The languages returned by {@link #getLanguages} from the CLDR raw data do not contain the
     * language names if they can be derived from the language and the script or the territory.
     * If the map of languages contains no entry for the given language tag, derive the language
     * name from the used script or region.
     *
     * @param {string} sLanguageTag
     *   The language tag, for example "en", "en-US", "en_US", "zh-Hant", or "zh_Hant"
     * @returns {string|undefined}
     *   The language name, or <code>undefined</code> if the name cannot be determined
     * @throws {TypeError} When the given language tag isn't valid
     *
     * @public
     */
    getLanguageName: function(sLanguageTag) {
      const oLanguageTag = new LanguageTag_default(sLanguageTag);
      let sLanguage = Localization_default.getModernLanguage(oLanguageTag.language);
      let sScript = oLanguageTag.script;
      if (sLanguage === "sr" && sScript === "Latn") {
        sLanguage = "sh";
        sScript = null;
      }
      const sRegion = oLanguageTag.region;
      const oLanguages = this._get("languages");
      const sLanguageText = oLanguages[sLanguage];
      if (!sScript && !sRegion || !sLanguageText) {
        return sLanguageText;
      }
      const sResult = oLanguages[sLanguage + "_" + sRegion] || oLanguages[sLanguage + "_" + sScript];
      if (sResult) {
        return sResult;
      }
      if (sScript) {
        const sScriptText = this._get("scripts")[sScript];
        if (sScriptText) {
          return sLanguageText + " (" + sScriptText + ")";
        }
      }
      if (sRegion) {
        const sRegionText = this._get("territories")[sRegion];
        if (sRegionText) {
          return sLanguageText + " (" + sRegionText + ")";
        }
      }
      return sLanguageText;
    },
    /**
     * Gets locale-specific language names, as available in the CLDR raw data.
     *
     * To avoid redundancies, with CLDR version 43 only language names are contained which cannot be derived from
     * the language and the script or the territory. If a language tag is not contained in the map, use
     * {@link #getLanguageName} to get the derived locale-specific language name for that language tag.
     *
     * @returns {Object<string, string>} Maps a language tag to the locale-specific language name
     *
     * @public
     */
    getLanguages: function() {
      const oLanguages = this._get("languages");
      ["ar_001", "de_AT", "de_CH", "en_AU", "en_CA", "en_GB", "en_US", "es_419", "es_ES", "es_MX", "fa_AF", "fr_CA", "fr_CH", "nds_NL", "nl_BE", "pt_BR", "pt_PT", "ro_MD", "sw_CD", "zh_Hans", "zh_Hant"].forEach((sLanguageTag) => {
        if (!oLanguages[sLanguageTag]) {
          oLanguages[sLanguageTag] = this.getLanguageName(sLanguageTag);
        }
      });
      return oLanguages;
    },
    /**
     * Gets locale-specific script names, as available in the CLDR raw data.
     *
     * To avoid redundancies, with CLDR version 43 only scripts are contained for which the language-specific name
     * is different from the script key. If a script key is not contained in the map, use the script key as script
     * name.
     *
     * @returns {Object<string, string>} Maps a script key to the locale-specific script name
     *
     * @public
     */
    getScripts: function() {
      return this._get("scripts");
    },
    /**
     * Gets locale-specific territory names, as available in the CLDR raw data.
     *
     * To avoid redundancies, with CLDR version 43 only territories are contained for which the language-specific
     * name is different from the territory key.
     *
     * @returns {Object<string, string>} Maps a territory key to the locale-specific territory name
     *
     * @public
     */
    getTerritories: function() {
      return this._get("territories");
    },
    /**
     * Get month names in width "narrow", "abbreviated" or "wide".
     *
     * @param {"narrow"|"abbreviated"|"wide"} sWidth
     *   The required width for the month names
     * @param {sap.ui.core.CalendarType} [sCalendarType]
     *   The type of calendar; defaults to the calendar type either set in configuration or calculated from locale
     * @returns {string[]}
     *   The array of month names
     * @public
     */
    getMonths: function(sWidth, sCalendarType) {
      assert_default(aSupportedWidths.includes(sWidth), "sWidth must be narrow, abbreviated or wide");
      return this._get(getCLDRCalendarName(sCalendarType), "months", "format", sWidth).map((vMonthName) => {
        return Array.isArray(vMonthName) ? vMonthName[0] : vMonthName;
      });
    },
    /**
     * Get standalone month names in width "narrow", "abbreviated" or "wide".
     *
     * @param {"narrow"|"abbreviated"|"wide"} sWidth
     *   The required width for the month names
     * @param {sap.ui.core.CalendarType} [sCalendarType]
     *   The type of calendar; defaults to the calendar type either set in configuration or calculated from locale
     * @returns {string[]}
     *   The array of standalone month names
     * @public
     */
    getMonthsStandAlone: function(sWidth, sCalendarType) {
      assert_default(aSupportedWidths.includes(sWidth), "sWidth must be narrow, abbreviated or wide");
      return this._get(getCLDRCalendarName(sCalendarType), "months", "stand-alone", sWidth).map((vMonthName) => {
        return Array.isArray(vMonthName) ? vMonthName[0] : vMonthName;
      });
    },
    /**
     * Get day names in width "narrow", "abbreviated" or "wide".
     *
     * @param {string} sWidth the required width for the day names
     * @param {sap.ui.core.CalendarType} [sCalendarType] the type of calendar. If it's not set, it falls back to the calendar type either set in configuration or calculated from locale.
     * @returns {array} array of day names (starting with Sunday)
     * @public
     */
    getDays: function(sWidth, sCalendarType) {
      assert_default(sWidth == "narrow" || sWidth == "abbreviated" || sWidth == "wide" || sWidth == "short", "sWidth must be narrow, abbreviate, wide or short");
      return this._get(getCLDRCalendarName(sCalendarType), "days", "format", sWidth);
    },
    /**
     * Get standalone day names in width "narrow", "abbreviated" or "wide".
     *
     * @param {string} sWidth the required width for the day names
     * @param {sap.ui.core.CalendarType} [sCalendarType] the type of calendar. If it's not set, it falls back to the calendar type either set in configuration or calculated from locale.
     * @returns {array} array of day names (starting with Sunday)
     * @public
     */
    getDaysStandAlone: function(sWidth, sCalendarType) {
      assert_default(sWidth == "narrow" || sWidth == "abbreviated" || sWidth == "wide" || sWidth == "short", "sWidth must be narrow, abbreviated, wide or short");
      return this._get(getCLDRCalendarName(sCalendarType), "days", "stand-alone", sWidth);
    },
    /**
     * Get quarter names in width "narrow", "abbreviated" or "wide".
     *
     * @param {string} sWidth the required width for the quarter names
     * @param {sap.ui.core.CalendarType} [sCalendarType] the type of calendar. If it's not set, it falls back to the calendar type either set in configuration or calculated from locale.
     * @returns {array} array of quarters
     * @public
     */
    getQuarters: function(sWidth, sCalendarType) {
      assert_default(sWidth == "narrow" || sWidth == "abbreviated" || sWidth == "wide", "sWidth must be narrow, abbreviated or wide");
      return this._get(getCLDRCalendarName(sCalendarType), "quarters", "format", sWidth);
    },
    /**
     * Get standalone quarter names in width "narrow", "abbreviated" or "wide".
     *
     * @param {string} sWidth the required width for the quarter names
     * @param {sap.ui.core.CalendarType} [sCalendarType] the type of calendar. If it's not set, it falls back to the calendar type either set in configuration or calculated from locale.
     * @returns {array} array of quarters
     * @public
     */
    getQuartersStandAlone: function(sWidth, sCalendarType) {
      assert_default(sWidth == "narrow" || sWidth == "abbreviated" || sWidth == "wide", "sWidth must be narrow, abbreviated or wide");
      return this._get(getCLDRCalendarName(sCalendarType), "quarters", "stand-alone", sWidth);
    },
    /**
     * Get day periods in width "narrow", "abbreviated" or "wide".
     *
     * @param {string} sWidth the required width for the day period names
     * @param {sap.ui.core.CalendarType} [sCalendarType] the type of calendar. If it's not set, it falls back to the calendar type either set in configuration or calculated from locale.
     * @returns {array} array of day periods (AM, PM)
     * @public
     */
    getDayPeriods: function(sWidth, sCalendarType) {
      assert_default(sWidth == "narrow" || sWidth == "abbreviated" || sWidth == "wide", "sWidth must be narrow, abbreviated or wide");
      return this._get(getCLDRCalendarName(sCalendarType), "dayPeriods", "format", sWidth);
    },
    /**
     * Get standalone day periods in width "narrow", "abbreviated" or "wide".
     *
     * @param {string} sWidth the required width for the day period names
     * @param {sap.ui.core.CalendarType} [sCalendarType] the type of calendar. If it's not set, it falls back to the calendar type either set in configuration or calculated from locale.
     * @returns {array} array of day periods (AM, PM)
     * @public
     */
    getDayPeriodsStandAlone: function(sWidth, sCalendarType) {
      assert_default(sWidth == "narrow" || sWidth == "abbreviated" || sWidth == "wide", "sWidth must be narrow, abbreviated or wide");
      return this._get(getCLDRCalendarName(sCalendarType), "dayPeriods", "stand-alone", sWidth);
    },
    /**
     * Get date pattern in format "short", "medium", "long" or "full".
     *
     * @param {string} sStyle the required style for the date pattern
     * @param {sap.ui.core.CalendarType} [sCalendarType] the type of calendar. If it's not set, it falls back to the calendar type either set in configuration or calculated from locale.
     * @returns {string} the selected date pattern
     * @public
     */
    getDatePattern: function(sStyle, sCalendarType) {
      assert_default(sStyle == "short" || sStyle == "medium" || sStyle == "long" || sStyle == "full", "sStyle must be short, medium, long or full");
      return this._get(getCLDRCalendarName(sCalendarType), "dateFormats", sStyle);
    },
    /**
     * Get flexible day periods in style format "abbreviated", "narrow" or "wide".
     *
     * @param {string} sWidth
     *   The required width for the flexible day period names
     * @param {sap.ui.core.CalendarType} [sCalendarType]
     *   The type of calendar. If it's not set, it falls back to the calendar type either set in
     *   configuration or calculated from locale.
     * @returns {object|undefined}
     *   Object of flexible day periods or 'undefined' if none can be found
     *
     * @example <caption>Output</caption>
     * {
     *   "midnight": "midnight",
     *   "noon": "noon",
     *   "morning1": "in the morning",
     *   "afternoon1": "in the afternoon",
     *   "evening1": "in the evening",
     *   "night1": "at night"
     * }
     *
     * @private
     */
    getFlexibleDayPeriods: function(sWidth, sCalendarType) {
      return this._get(getCLDRCalendarName(sCalendarType), "flexibleDayPeriods", "format", sWidth);
    },
    /**
     * Get flexible day periods in style format "abbreviated", "narrow" or "wide" for case
     * "stand-alone".
     *
     * @param {string} sWidth
     *   The required width for the flexible day period names
     * @param {sap.ui.core.CalendarType} [sCalendarType]
     *   The type of calendar. If it's not set, it falls back to the calendar type either set in
     *   configuration or calculated from locale.
     * @returns {object|undefined}
     *   Object of flexible day periods or 'undefined' if none can be found
     *
     * @example <caption>Output</caption>
     * {
     *   "midnight": "midnight",
     *   "noon": "noon",
     *   "morning1": "in the morning",
     *   "afternoon1": "in the afternoon",
     *   "evening1": "in the evening",
     *   "night1": "at night"
     * }
     *
     * @private
     */
    getFlexibleDayPeriodsStandAlone: function(sWidth, sCalendarType) {
      return this._get(getCLDRCalendarName(sCalendarType), "flexibleDayPeriods", "stand-alone", sWidth);
    },
    /**
     * Get flexible day period of time or a point in time
     *
     * @param {int} iHour Hour
     * @param {int} iMinute Minute
     * @returns {string} Key of flexible day period of time e.g. <code>afternoon2</code>
     *
     * @private
     */
    getFlexibleDayPeriodOfTime: function(iHour, iMinute) {
      var iAbsoluteMinutes, oDayPeriodRules, sPeriodMatch;
      iAbsoluteMinutes = (iHour * 60 + iMinute) % 1440;
      oDayPeriodRules = this._get("dayPeriodRules");
      function parseToAbsoluteMinutes(sValue) {
        var aSplit = sValue.split(":"), sHour = aSplit[0], sMinute = aSplit[1];
        return parseInt(sHour) * 60 + parseInt(sMinute);
      }
      sPeriodMatch = Object.keys(oDayPeriodRules).find(function(sDayPeriodRule) {
        var oDayPeriodRule = oDayPeriodRules[sDayPeriodRule];
        return oDayPeriodRule["_at"] && parseToAbsoluteMinutes(oDayPeriodRule["_at"]) === iAbsoluteMinutes;
      });
      if (sPeriodMatch) {
        return sPeriodMatch;
      }
      return Object.keys(oDayPeriodRules).find(function(sDayPeriodRule) {
        var iEndValue, aIntervals, iStartValue, oDayPeriodRule = oDayPeriodRules[sDayPeriodRule];
        if (oDayPeriodRule["_at"]) {
          return false;
        }
        iStartValue = parseToAbsoluteMinutes(oDayPeriodRule["_from"]);
        iEndValue = parseToAbsoluteMinutes(oDayPeriodRule["_before"]);
        if (iStartValue > iEndValue) {
          aIntervals = [
            {
              start: iStartValue,
              end: 1440
            },
            // 24 * 60
            {
              start: 0,
              end: iEndValue
            }
          ];
        } else {
          aIntervals = [{
            start: iStartValue,
            end: iEndValue
          }];
        }
        return aIntervals.some(function(oInterval) {
          return oInterval.start <= iAbsoluteMinutes && oInterval.end > iAbsoluteMinutes;
        });
      });
    },
    /**
     * Get time pattern in style "short", "medium", "long" or "full".
     *
     * @param {string} sStyle the required style for the date pattern
     * @param {sap.ui.core.CalendarType} [sCalendarType] the type of calendar. If it's not set, it falls back to the calendar type either set in configuration or calculated from locale.
     * @returns {string} the selected time pattern
     * @public
     */
    getTimePattern: function(sStyle, sCalendarType) {
      assert_default(sStyle == "short" || sStyle == "medium" || sStyle == "long" || sStyle == "full", "sStyle must be short, medium, long or full");
      return this._get(getCLDRCalendarName(sCalendarType), "timeFormats", sStyle);
    },
    /**
     * Get datetime pattern in style "short", "medium", "long" or "full".
     *
     * @param {string} sStyle the required style for the datetime pattern
     * @param {sap.ui.core.CalendarType} [sCalendarType] the type of calendar. If it's not set, it falls back to the calendar type either set in configuration or calculated from locale.
     * @returns {string} the selected datetime pattern
     * @public
     */
    getDateTimePattern: function(sStyle, sCalendarType) {
      assert_default(sStyle == "short" || sStyle == "medium" || sStyle == "long" || sStyle == "full", "sStyle must be short, medium, long or full");
      return this._get(getCLDRCalendarName(sCalendarType), "dateTimeFormats", sStyle);
    },
    /**
     * Get combined datetime pattern with given date and time style.
     *
     * @param {string} sDateStyle the required style for the date part
     * @param {string} sTimeStyle the required style for the time part
     * @param {sap.ui.core.CalendarType} [sCalendarType] the type of calendar. If it's not set, it falls back to the calendar type either set in configuration or calculated from locale.
     * @returns {string} the combined datetime pattern
     * @public
     */
    getCombinedDateTimePattern: function(sDateStyle, sTimeStyle, sCalendarType) {
      assert_default(sDateStyle == "short" || sDateStyle == "medium" || sDateStyle == "long" || sDateStyle == "full", "sStyle must be short, medium, long or full");
      assert_default(sTimeStyle == "short" || sTimeStyle == "medium" || sTimeStyle == "long" || sTimeStyle == "full", "sStyle must be short, medium, long or full");
      var sDateTimePattern = this.getDateTimePattern(sDateStyle, sCalendarType), sDatePattern = this.getDatePattern(sDateStyle, sCalendarType), sTimePattern = this.getTimePattern(sTimeStyle, sCalendarType);
      return sDateTimePattern.replace("{0}", sTimePattern).replace("{1}", sDatePattern);
    },
    /**
     * Get combined pattern with datetime and timezone for the given date and time style.
     *
     * @example
     * // locale de
     * oLocaleData.getCombinedDateTimeWithTimezonePattern("long", "long");
     * // "d. MMMM y 'um' HH:mm:ss z VV"
     *
     * // locale en_GB
     * oLocaleData.getCombinedDateTimeWithTimezonePattern("long", "long");
     * // "d MMMM y 'at' HH:mm:ss z VV"
     *
     * @param {string} sDateStyle The required style for the date part
     * @param {string} sTimeStyle The required style for the time part
     * @param {sap.ui.core.CalendarType} [sCalendarType] The type of calendar. If it's not set,
     *   it falls back to the calendar type either set in the configuration or calculated from
     *   the locale.
     * @returns {string} the combined pattern with datetime and timezone
     * @private
     * @ui5-restricted sap.ui.core.format.DateFormat
     * @since 1.101
     */
    getCombinedDateTimeWithTimezonePattern: function(sDateStyle, sTimeStyle, sCalendarType) {
      return this.applyTimezonePattern(this.getCombinedDateTimePattern(sDateStyle, sTimeStyle, sCalendarType));
    },
    /**
     * Applies the timezone to the pattern
     *
     * @param {string} sPattern pattern, e.g. <code>y</code>
     * @returns {string} applied timezone, e.g. <code>y VV</code>
     * @private
     * @ui5-restricted sap.ui.core.format.DateFormat
     * @since 1.101
     */
    applyTimezonePattern: function(sPattern) {
      var aPatterns = [sPattern];
      var aMissingTokens = [{
        group: "Timezone",
        length: 2,
        field: "zone",
        symbol: "V"
      }];
      this._appendItems(aPatterns, aMissingTokens);
      return aPatterns[0];
    },
    /**
     * Retrieves all timezone translations.
     *
     * E.g. for locale "en"
     * <pre>
     * {
     *  "America/New_York": "Americas, New York"
     *  ...
     * }
     * </pre>
     *
     * @return {Object<string, string>} the mapping, with 'key' being the IANA timezone ID, and
     * 'value' being the translation.
     * @ui5-restricted sap.ui.core.format.DateFormat, sap.ui.export, sap.ushell
     * @private
     */
    getTimezoneTranslations: function() {
      var sLocale = this.oLocale.toString();
      var mTranslations = LocaleData._mTimezoneTranslations[sLocale];
      if (!mTranslations) {
        LocaleData._mTimezoneTranslations[sLocale] = mTranslations = _resolveTimezoneTranslationStructure(this._get("timezoneNames"));
      }
      return Object.assign({}, mTranslations);
    },
    /**
     * Get custom datetime pattern for a given skeleton format.
     *
     * The format string does contain pattern symbols (e.g. "yMMMd" or "Hms") and will be converted into the pattern in the used
     * locale, which matches the wanted symbols best. The symbols must be in canonical order, that is:
     * Era (G), Year (y/Y), Quarter (q/Q), Month (M/L), Week (w/W), Day-Of-Week (E/e/c), Day (d/D),
     * Hour (h/H/k/K/), Minute (m), Second (s), Timezone (z/Z/v/V/O/X/x)
     *
     * See https://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems
     *
     * @param {string} sSkeleton the wanted skeleton format for the datetime pattern
     * @param {sap.ui.core.CalendarType} [sCalendarType] the type of calendar. If it's not set, it falls back to the calendar type either set in configuration or calculated from locale.
     * @returns {string} the best matching datetime pattern
     * @since 1.34
     * @public
     */
    getCustomDateTimePattern: function(sSkeleton, sCalendarType) {
      var oAvailableFormats = this._get(getCLDRCalendarName(sCalendarType), "dateTimeFormats", "availableFormats");
      return this._getFormatPattern(sSkeleton, oAvailableFormats, sCalendarType);
    },
    /**
     * Returns the interval format with the given Id (see CLDR documentation for valid Ids)
     * or the fallback format if no interval format with that Id is known.
     *
     * The empty Id ("") might be used to retrieve the interval format fallback.
     *
     * @param {string} sId Id of the interval format, e.g. "d-d"
     * @param {sap.ui.core.CalendarType} [sCalendarType] the type of calendar. If it's not set, it falls back to the calendar type either set in configuration or calculated from locale.
     * @returns {string} interval format string with placeholders {0} and {1}
     * @public
     * @since 1.17.0
     */
    getIntervalPattern: function(sId, sCalendarType) {
      var oIntervalFormats = this._get(getCLDRCalendarName(sCalendarType), "dateTimeFormats", "intervalFormats"), aIdParts, sIntervalId, sDifference, oInterval, sPattern;
      if (sId) {
        aIdParts = sId.split("-");
        sIntervalId = aIdParts[0];
        sDifference = aIdParts[1];
        oInterval = oIntervalFormats[sIntervalId];
        if (oInterval) {
          sPattern = oInterval[sDifference];
          if (sPattern) {
            return sPattern;
          }
        }
      }
      return oIntervalFormats.intervalFormatFallback;
    },
    /**
     * Get combined interval pattern using a given pattern and the fallback interval pattern.
     *
     * If a skeleton based pattern is not available or not wanted, this method can be used to create an interval
     * pattern based on a given pattern, using the fallback interval pattern.
     *
     * @param {string} sPattern the single date pattern to use within the interval pattern
     * @param {sap.ui.core.CalendarType} [sCalendarType] the type of calendar. If it's not set, it falls back to the calendar type either set in configuration or calculated from locale.
     * @returns {string} the calculated interval pattern
     * @since 1.46
     * @public
     */
    getCombinedIntervalPattern: function(sPattern, sCalendarType) {
      const oIntervalFormats = this._get(getCLDRCalendarName(sCalendarType), "dateTimeFormats", "intervalFormats");
      const [
        /*sAll*/
        ,
        sTextBefore,
        sTextBetween,
        sTextAfter
      ] = rFallbackPatternTextParts.exec(oIntervalFormats.intervalFormatFallback);
      return LocaleData._escapeIfNeeded(sTextBefore) + sPattern + LocaleData._escapeIfNeeded(sTextBetween) + sPattern + LocaleData._escapeIfNeeded(sTextAfter);
    },
    /**
     * Get interval pattern for a given skeleton format.
     *
     * The format string does contain pattern symbols (e.g. "yMMMd" or "Hms") and will be converted into the pattern in the used
     * locale, which matches the wanted symbols best. The symbols must be in canonical order, that is:
     * Era (G), Year (y/Y), Quarter (q/Q), Month (M/L), Week (w/W), Day-Of-Week (E/e/c), Day (d/D),
     * Hour (h/H/k/K/), Minute (m), Second (s), Timezone (z/Z/v/V/O/X/x)
     *
     * See https://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems
     *
     * @param {string} sSkeleton the wanted skeleton format for the datetime pattern
     * @param {object|string} vGreatestDiff is either a string which represents the symbol matching the greatest difference in the two dates to format or an object which contains key-value pairs.
     *  The value is always true. The key is one of the date field symbol groups whose value are different between the two dates. The key can only be set with 'Year', 'Quarter', 'Month', 'Week',
     *  'Day', 'DayPeriod', 'Hour', 'Minute', or 'Second'.
     * @param {sap.ui.core.CalendarType} [sCalendarType] the type of calendar. If it's not set, it falls back to the calendar type either set in configuration or calculated from locale.
     * @returns {string|string[]} the best matching interval pattern if interval difference is given otherwise an array with all possible interval patterns which match the given skeleton format
     * @since 1.46
     * @public
     */
    getCustomIntervalPattern: function(sSkeleton, vGreatestDiff, sCalendarType) {
      var oAvailableFormats = this._get(getCLDRCalendarName(sCalendarType), "dateTimeFormats", "intervalFormats");
      return this._getFormatPattern(sSkeleton, oAvailableFormats, sCalendarType, vGreatestDiff);
    },
    /* Helper functions for skeleton pattern processing */
    _getFormatPattern: function(sSkeleton, oAvailableFormats, sCalendarType, vDiff) {
      var vPattern, aPatterns, oIntervalFormats;
      if (!vDiff) {
        vPattern = oAvailableFormats[sSkeleton];
      } else if (typeof vDiff === "string") {
        if (vDiff == "j" || vDiff == "J") {
          vDiff = this.getPreferredHourSymbol();
        }
        oIntervalFormats = oAvailableFormats[sSkeleton];
        vPattern = oIntervalFormats && oIntervalFormats[vDiff];
      }
      if (vPattern) {
        if (typeof vPattern === "object") {
          aPatterns = Object.keys(vPattern).map(function(sKey) {
            return vPattern[sKey];
          });
        } else {
          return vPattern;
        }
      }
      if (!aPatterns) {
        aPatterns = this._createFormatPattern(sSkeleton, oAvailableFormats, sCalendarType, vDiff);
      }
      if (aPatterns && aPatterns.length === 1) {
        return aPatterns[0];
      }
      return aPatterns;
    },
    _createFormatPattern: function(sSkeleton, oAvailableFormats, sCalendarType, vDiff) {
      var aTokens = this._parseSkeletonFormat(sSkeleton), aPatterns, oBestMatch = this._findBestMatch(aTokens, sSkeleton, oAvailableFormats), oToken2, oAvailableDateTimeFormats, oSymbol, oGroup, sPattern, sSinglePattern, sDiffSymbol, sDiffGroup, rMixedSkeleton = /^([GyYqQMLwWEecdD]+)([hHkKjJmszZvVOXx]+)$/, bSingleDate, i;
      if (vDiff) {
        if (typeof vDiff === "string") {
          sDiffGroup = mCLDRSymbols[vDiff] ? mCLDRSymbols[vDiff].group : "";
          if (sDiffGroup) {
            bSingleDate = mCLDRSymbolGroups[sDiffGroup].index > aTokens[aTokens.length - 1].index;
          }
          sDiffSymbol = vDiff;
        } else {
          bSingleDate = true;
          if (aTokens[0].symbol === "y" && oBestMatch && oBestMatch.pattern.G) {
            oSymbol = mCLDRSymbols["G"];
            oGroup = mCLDRSymbolGroups[oSymbol.group];
            aTokens.splice(0, 0, {
              symbol: "G",
              group: oSymbol.group,
              match: oSymbol.match,
              index: oGroup.index,
              field: oGroup.field,
              length: 1
            });
          }
          for (i = aTokens.length - 1; i >= 0; i--) {
            oToken2 = aTokens[i];
            if (vDiff[oToken2.group]) {
              bSingleDate = false;
              break;
            }
          }
          for (i = 0; i < aTokens.length; i++) {
            oToken2 = aTokens[i];
            if (vDiff[oToken2.group]) {
              sDiffSymbol = oToken2.symbol;
              break;
            }
          }
          if ((sDiffSymbol == "h" || sDiffSymbol == "K") && vDiff.DayPeriod) {
            sDiffSymbol = "a";
          }
        }
        if (bSingleDate) {
          return [this.getCustomDateTimePattern(sSkeleton, sCalendarType)];
        }
        if (oBestMatch && oBestMatch.missingTokens.length === 0) {
          sPattern = oBestMatch.pattern[sDiffSymbol];
          if (sPattern && oBestMatch.distance > 0) {
            sPattern = this._expandFields(sPattern, oBestMatch.patternTokens, aTokens);
          }
        }
        if (!sPattern) {
          oAvailableDateTimeFormats = this._get(getCLDRCalendarName(sCalendarType), "dateTimeFormats", "availableFormats");
          if (rMixedSkeleton.test(sSkeleton) && "ahHkKjJms".indexOf(sDiffSymbol) >= 0) {
            sPattern = this._getMixedFormatPattern(sSkeleton, oAvailableDateTimeFormats, sCalendarType, vDiff);
          } else {
            sSinglePattern = this._getFormatPattern(sSkeleton, oAvailableDateTimeFormats, sCalendarType);
            sPattern = this.getCombinedIntervalPattern(sSinglePattern, sCalendarType);
          }
        }
        aPatterns = [sPattern];
      } else if (!oBestMatch) {
        sPattern = sSkeleton;
        aPatterns = [sPattern];
      } else {
        if (typeof oBestMatch.pattern === "string") {
          aPatterns = [oBestMatch.pattern];
        } else if (typeof oBestMatch.pattern === "object") {
          aPatterns = [];
          for (var sKey in oBestMatch.pattern) {
            sPattern = oBestMatch.pattern[sKey];
            aPatterns.push(sPattern);
          }
        }
        if (oBestMatch.distance > 0) {
          if (oBestMatch.missingTokens.length > 0) {
            if (rMixedSkeleton.test(sSkeleton)) {
              aPatterns = [this._getMixedFormatPattern(sSkeleton, oAvailableFormats, sCalendarType)];
            } else {
              aPatterns = this._expandFields(aPatterns, oBestMatch.patternTokens, aTokens);
              aPatterns = this._appendItems(aPatterns, oBestMatch.missingTokens, sCalendarType);
            }
          } else {
            aPatterns = this._expandFields(aPatterns, oBestMatch.patternTokens, aTokens);
          }
        }
      }
      if (sSkeleton.indexOf("J") >= 0) {
        aPatterns.forEach(function(sPattern2, iIndex) {
          aPatterns[iIndex] = sPattern2.replace(/ ?[abB](?=([^']*'[^']*')*[^']*)$/g, "");
        });
      }
      return aPatterns;
    },
    _parseSkeletonFormat: function(sSkeleton) {
      var aTokens = [], oToken2 = {
        index: -1
      }, sSymbol, oSymbol, oGroup;
      for (var i = 0; i < sSkeleton.length; i++) {
        sSymbol = sSkeleton.charAt(i);
        if (sSymbol == "j" || sSymbol == "J") {
          sSymbol = this.getPreferredHourSymbol();
        }
        if (sSymbol == oToken2.symbol) {
          oToken2.length++;
          continue;
        }
        oSymbol = mCLDRSymbols[sSymbol];
        oGroup = mCLDRSymbolGroups[oSymbol.group];
        if (oSymbol.group == "Other" || oGroup.diffOnly) {
          throw new Error("Symbol '" + sSymbol + "' is not allowed in skeleton format '" + sSkeleton + "'");
        }
        if (oGroup.index <= oToken2.index) {
          throw new Error("Symbol '" + sSymbol + "' at wrong position or duplicate in skeleton format '" + sSkeleton + "'");
        }
        oToken2 = {
          symbol: sSymbol,
          group: oSymbol.group,
          match: oSymbol.match,
          index: oGroup.index,
          field: oGroup.field,
          length: 1
        };
        aTokens.push(oToken2);
      }
      return aTokens;
    },
    _findBestMatch: function(aTokens, sSkeleton, oAvailableFormats) {
      var aTestTokens, aMissingTokens, oToken2, oTestToken, iTest, iDistance, bMatch, iFirstDiffPos, oTokenSymbol, oTestTokenSymbol, oBestMatch = {
        distance: 1e4,
        firstDiffPos: -1
      };
      for (var sTestSkeleton in oAvailableFormats) {
        if (sTestSkeleton === "intervalFormatFallback" || sTestSkeleton.indexOf("B") > -1) {
          continue;
        }
        aTestTokens = this._parseSkeletonFormat(sTestSkeleton);
        iDistance = 0;
        aMissingTokens = [];
        bMatch = true;
        if (aTokens.length < aTestTokens.length) {
          continue;
        }
        iTest = 0;
        iFirstDiffPos = aTokens.length;
        for (var i = 0; i < aTokens.length; i++) {
          oToken2 = aTokens[i];
          oTestToken = aTestTokens[iTest];
          if (iFirstDiffPos === aTokens.length) {
            iFirstDiffPos = i;
          }
          if (oTestToken) {
            oTokenSymbol = mCLDRSymbols[oToken2.symbol];
            oTestTokenSymbol = mCLDRSymbols[oTestToken.symbol];
            if (oToken2.symbol === oTestToken.symbol) {
              if (oToken2.length === oTestToken.length) {
                if (iFirstDiffPos === i) {
                  iFirstDiffPos = aTokens.length;
                }
              } else {
                if (oToken2.length < oTokenSymbol.numericCeiling ? oTestToken.length < oTestTokenSymbol.numericCeiling : oTestToken.length >= oTestTokenSymbol.numericCeiling) {
                  iDistance += Math.abs(oToken2.length - oTestToken.length);
                } else {
                  iDistance += 5;
                }
              }
              iTest++;
              continue;
            } else {
              if (oToken2.match == oTestToken.match) {
                iDistance += Math.abs(oToken2.length - oTestToken.length) + 10;
                iTest++;
                continue;
              }
            }
          }
          aMissingTokens.push(oToken2);
          iDistance += 50 - i;
        }
        if (iTest < aTestTokens.length) {
          bMatch = false;
        }
        if (bMatch && (iDistance < oBestMatch.distance || iDistance === oBestMatch.distance && iFirstDiffPos > oBestMatch.firstDiffPos)) {
          oBestMatch.distance = iDistance;
          oBestMatch.firstDiffPos = iFirstDiffPos;
          oBestMatch.missingTokens = aMissingTokens;
          oBestMatch.pattern = oAvailableFormats[sTestSkeleton];
          oBestMatch.patternTokens = aTestTokens;
        }
      }
      if (oBestMatch.pattern) {
        return oBestMatch;
      }
    },
    _expandFields: function(vPattern, aPatternTokens, aTokens) {
      var bSinglePattern = typeof vPattern === "string";
      var aPatterns;
      if (bSinglePattern) {
        aPatterns = [vPattern];
      } else {
        aPatterns = vPattern;
      }
      var aResult = aPatterns.map(function(sPattern) {
        var mGroups = {}, mPatternGroups = {}, sResultPatterm = "", bQuoted = false, i = 0, iSkeletonLength, iPatternLength, iBestLength, iNewLength, oSkeletonToken, oBestToken, oSymbol, sChar;
        aTokens.forEach(function(oToken2) {
          mGroups[oToken2.group] = oToken2;
        });
        aPatternTokens.forEach(function(oToken2) {
          mPatternGroups[oToken2.group] = oToken2;
        });
        while (i < sPattern.length) {
          sChar = sPattern.charAt(i);
          if (bQuoted) {
            sResultPatterm += sChar;
            if (sChar == "'") {
              bQuoted = false;
            }
          } else {
            oSymbol = mCLDRSymbols[sChar];
            if (oSymbol && mGroups[oSymbol.group] && mPatternGroups[oSymbol.group]) {
              oSkeletonToken = mGroups[oSymbol.group];
              oBestToken = mPatternGroups[oSymbol.group];
              iSkeletonLength = oSkeletonToken.length;
              iBestLength = oBestToken.length;
              iPatternLength = 1;
              while (sPattern.charAt(i + 1) == sChar) {
                i++;
                iPatternLength++;
              }
              if (iSkeletonLength === iBestLength || (iSkeletonLength < oSymbol.numericCeiling ? iPatternLength >= oSymbol.numericCeiling : iPatternLength < oSymbol.numericCeiling)) {
                iNewLength = iPatternLength;
              } else {
                iNewLength = Math.max(iPatternLength, iSkeletonLength);
              }
              for (var j = 0; j < iNewLength; j++) {
                sResultPatterm += sChar;
              }
            } else {
              sResultPatterm += sChar;
              if (sChar == "'") {
                bQuoted = true;
              }
            }
          }
          i++;
        }
        return sResultPatterm;
      });
      return bSinglePattern ? aResult[0] : aResult;
    },
    _appendItems: function(aPatterns, aMissingTokens, sCalendarType) {
      var oAppendItems = this._get(getCLDRCalendarName(sCalendarType), "dateTimeFormats", "appendItems");
      aPatterns.forEach((function(sPattern, iIndex) {
        var sDisplayName, sAppendPattern, sAppendField;
        aMissingTokens.forEach((function(oToken2) {
          sAppendPattern = oAppendItems[oToken2.group];
          sDisplayName = "'" + this.getDisplayName(oToken2.field) + "'";
          sAppendField = "";
          for (var i = 0; i < oToken2.length; i++) {
            sAppendField += oToken2.symbol;
          }
          aPatterns[iIndex] = sAppendPattern.replace(/\{0\}/, sPattern).replace(/\{1\}/, sAppendField).replace(/\{2\}/, sDisplayName);
        }).bind(this));
      }).bind(this));
      return aPatterns;
    },
    _getMixedFormatPattern: function(sSkeleton, oAvailableFormats, sCalendarType, vDiff) {
      var rMixedSkeleton = /^([GyYqQMLwWEecdD]+)([hHkKjJmszZvVOXx]+)$/, rWideMonth = /MMMM|LLLL/, rAbbrevMonth = /MMM|LLL/, rWeekDay = /E|e|c/, oResult, sDateSkeleton, sTimeSkeleton, sStyle, sDatePattern, sTimePattern, sDateTimePattern, sResultPattern;
      oResult = rMixedSkeleton.exec(sSkeleton);
      sDateSkeleton = oResult[1];
      sTimeSkeleton = oResult[2];
      sDatePattern = this._getFormatPattern(sDateSkeleton, oAvailableFormats, sCalendarType);
      if (vDiff) {
        sTimePattern = this.getCustomIntervalPattern(sTimeSkeleton, vDiff, sCalendarType);
      } else {
        sTimePattern = this._getFormatPattern(sTimeSkeleton, oAvailableFormats, sCalendarType);
      }
      if (rWideMonth.test(sDateSkeleton)) {
        sStyle = rWeekDay.test(sDateSkeleton) ? "full" : "long";
      } else if (rAbbrevMonth.test(sDateSkeleton)) {
        sStyle = "medium";
      } else {
        sStyle = "short";
      }
      sDateTimePattern = this.getDateTimePattern(sStyle, sCalendarType);
      sResultPattern = sDateTimePattern.replace(/\{1\}/, sDatePattern).replace(/\{0\}/, sTimePattern);
      return sResultPattern;
    },
    /**
     * Get number symbol "decimal", "group", "plusSign", "minusSign", "percentSign".
     *
     * @param {string} sType the required type of symbol
     * @returns {string} the selected number symbol
     * @public
     */
    getNumberSymbol: function(sType) {
      assert_default(sType == "decimal" || sType == "group" || sType == "plusSign" || sType == "minusSign" || sType == "percentSign", "sType must be decimal, group, plusSign, minusSign or percentSign");
      return this._get("symbols-latn-" + sType);
    },
    /**
     * Get lenient number symbols for "plusSign" or "minusSign".
     *
     * @param {string} sType the required type of symbol
     * @returns {string} the selected lenient number symbols, e.g. "-‒⁻₋−➖﹣"
     * @public
     */
    getLenientNumberSymbols: function(sType) {
      assert_default(sType == "plusSign" || sType == "minusSign", "sType must be plusSign or minusSign");
      return this._get("lenient-scope-number")[sType];
    },
    /**
     * Get decimal format pattern.
     *
     * @returns {string} The pattern
     * @public
     */
    getDecimalPattern: function() {
      return this._get("decimalFormat").standard;
    },
    /**
     * Get currency format pattern.
     *
     * CLDR format pattern:
     *
     * @example standard with currency symbol in front of the number
     * ¤#,##0.00
     * $100,000.00
     * $-100,000.00
     *
     * @example accounting with negative number pattern after the semicolon
     * ¤#,##0.00;(¤#,##0.00)
     * $100,000.00
     * ($100,000.00)
     *
     * @see https://cldr.unicode.org/translation/numbers-currency/number-patterns
     *
     * @param {string} sContext the context of the currency pattern (standard or accounting)
     * @returns {string} The pattern
     * @public
     */
    getCurrencyPattern: function(sContext) {
      return this._get("currencyFormat")[sContext] || this._get("currencyFormat").standard;
    },
    getCurrencySpacing: function(sPosition) {
      return this._get("currencyFormat", "currencySpacing", sPosition === "after" ? "afterCurrency" : "beforeCurrency");
    },
    /**
     * Get percent format pattern.
     *
     * @returns {string} The pattern
     * @public
     */
    getPercentPattern: function() {
      return this._get("percentFormat").standard;
    },
    /**
     * Get miscellaneous pattern.
     *
     * @param {string} sName the name of the misc pattern, can be "approximately", "atLeast", "atMost" or "range"
     * @returns {string} The pattern
     * @public
     */
    getMiscPattern: function(sName) {
      assert_default(sName == "approximately" || sName == "atLeast" || sName == "atMost" || sName == "range", "sName must be approximately, atLeast, atMost or range");
      return this._get("miscPattern")[sName];
    },
    /**
     * Returns the required minimal number of days for the first week of a year.
     *
     * This is the minimal number of days of the week which must be contained in the new year
     * for the week to become the first week of the year. Depending on the country, this
     * is just a single day (in the US) or at least 4 days (in most of Europe).
     *
     * All week data information in the CLDR is provided for territories (countries).
     * If the locale of this LocaleData doesn't contain country information (e.g. if it
     * contains only a language), then the "likelySubtag" information of the CLDR
     * is taken into account to guess the "most likely" territory for the locale.
     *
     * @returns {int} minimal number of days
     * @public
     */
    getMinimalDaysInFirstWeek: function() {
      return this._get("weekData-minDays");
    },
    /**
     * Returns the day that usually is regarded as the first day
     * of a week in the current locale.
     *
     * Days are encoded as integer where Sunday=0, Monday=1 etc.
     *
     * All week data information in the CLDR is provided for territories (countries).
     * If the locale of this LocaleData doesn't contain country information (e.g. if it
     * contains only a language), then the "likelySubtag" information of the CLDR
     * is taken into account to guess the "most likely" territory for the locale.
     *
     * @returns {int} first day of week
     * @public
     */
    getFirstDayOfWeek: function() {
      return this._get("weekData-firstDay");
    },
    /**
     * Returns the first day of a weekend for the given locale.
     *
     * Days are encoded in the same way as for {@link #getFirstDayOfWeek}.
     *
     * All week data information in the CLDR is provided for territories (countries).
     * If the locale of this LocaleData doesn't contain country information (e.g. if it
     * contains only a language), then the "likelySubtag" information of the CLDR
     * is taken into account to guess the "most likely" territory for the locale.
     *
     * @returns {int} first day of weekend
     * @public
     */
    getWeekendStart: function() {
      return this._get("weekData-weekendStart");
    },
    /**
     * Returns the last day of a weekend for the given locale.
     *
     * Days are encoded in the same way as for {@link #getFirstDayOfWeek}.
     *
     * All week data information in the CLDR is provided for territories (countries).
     * If the locale of this LocaleData doesn't contain country information (e.g. if it
     * contains only a language), then the "likelySubtag" information of the CLDR
     * is taken into account to guess the "most likely" territory for the locale.
     *
     * @returns {int} last day of weekend
     * @public
     */
    getWeekendEnd: function() {
      return this._get("weekData-weekendEnd");
    },
    /**
     * Returns a map of custom currency codes, defined via global configuration.
     * @returns {object} map of custom currency codes, e.g.
     * {
     *     "AUD": "AUD",
     *     "BRL": "BRL",
     *     "EUR": "EUR",
     *     "GBP": "GBP",
     * }
     * @private
     * @ui5-restricted sap.ui.core.format.NumberFormat
     * @since 1.63
     */
    getCustomCurrencyCodes: function() {
      var mCustomCurrencies = this._get("currency") || {}, mCustomCurrencyCodes = {};
      Object.keys(mCustomCurrencies).forEach(function(sCurrencyKey) {
        mCustomCurrencyCodes[sCurrencyKey] = sCurrencyKey;
      });
      return mCustomCurrencyCodes;
    },
    /**
     * Returns the number of digits of the specified currency.
     *
     * @param {string} sCurrency ISO 4217 currency code
     * @returns {int} digits of the currency
     * @public
     * @since 1.21.1
     */
    getCurrencyDigits: function(sCurrency) {
      var mCustomCurrencies = this._get("currency");
      if (mCustomCurrencies) {
        if (mCustomCurrencies[sCurrency] && mCustomCurrencies[sCurrency].hasOwnProperty("digits")) {
          return mCustomCurrencies[sCurrency].digits;
        } else if (mCustomCurrencies["DEFAULT"] && mCustomCurrencies["DEFAULT"].hasOwnProperty("digits")) {
          return mCustomCurrencies["DEFAULT"].digits;
        }
      }
      var iDigits = this._get("currencyDigits", sCurrency);
      if (iDigits == null) {
        iDigits = this._get("currencyDigits", "DEFAULT");
        if (iDigits == null) {
          iDigits = 2;
        }
      }
      return iDigits;
    },
    /**
     * Returns the currency symbol for the specified currency, if no symbol is found the ISO 4217 currency code is returned.
     *
     * @param {string} sCurrency ISO 4217 currency code
     * @returns {string} the currency symbol
     * @public
     * @since 1.21.1
     */
    getCurrencySymbol: function(sCurrency) {
      var oCurrencySymbols = this.getCurrencySymbols();
      return oCurrencySymbols && oCurrencySymbols[sCurrency] || sCurrency;
    },
    /**
     * Returns the currency code which is corresponded with the given currency symbol.
     *
     * @param {string} sCurrencySymbol The currency symbol which needs to be converted to currency code
     * @return {string} The corresponded currency code defined for the given currency symbol. The given currency symbol is returned if no currency code can be found by using the given currency symbol.
     * @public
     * @since 1.27.0
     */
    getCurrencyCodeBySymbol: function(sCurrencySymbol) {
      var oCurrencySymbols = this._get("currencySymbols"), sCurrencyCode;
      for (sCurrencyCode in oCurrencySymbols) {
        if (oCurrencySymbols[sCurrencyCode] === sCurrencySymbol) {
          return sCurrencyCode;
        }
      }
      return sCurrencySymbol;
    },
    /**
     * Returns the currency symbols available for this locale.
     * Currency symbols get accumulated by custom currency symbols.
     *
     * @returns {Object<string, string>} the map of all currency symbols available in this locale, e.g.
     * {
     *     "AUD": "A$",
     *     "BRL": "R$",
     *     "EUR": "€",
     *     "GBP": "£",
     * }
     * @public
     * @since 1.60
     */
    getCurrencySymbols: function() {
      var mCustomCurrencies = this._get("currency"), mCustomCurrencySymbols = {}, sIsoCode;
      for (var sCurrencyKey in mCustomCurrencies) {
        sIsoCode = mCustomCurrencies[sCurrencyKey].isoCode;
        if (mCustomCurrencies[sCurrencyKey].symbol) {
          mCustomCurrencySymbols[sCurrencyKey] = mCustomCurrencies[sCurrencyKey].symbol;
        } else if (sIsoCode) {
          mCustomCurrencySymbols[sCurrencyKey] = this._get("currencySymbols")[sIsoCode];
        }
      }
      return Object.assign({}, this._get("currencySymbols"), mCustomCurrencySymbols);
    },
    /**
     * Retrieves the localized display name of a unit by sUnit, e.g. "duration-hour".
     * @param {string} sUnit the unit key, e.g. "duration-hour"
     * @return {string} The localized display name for the requested unit, e.g. <code>"Hour"</code>. Return empty string <code>""</code> if not found
     * @public
     * @since 1.54
     */
    getUnitDisplayName: function(sUnit) {
      var mUnitFormat = this.getUnitFormat(sUnit);
      return mUnitFormat && mUnitFormat["displayName"] || "";
    },
    /**
     * Returns relative time patterns for the given scales as an array of objects containing scale, value and pattern.
     *
     * The array may contain the following values: "year", "month", "week", "day", "hour", "minute" and "second". If
     * no scales are given, patterns for all available scales will be returned.
     *
     * The return array will contain objects looking like:
     * <pre>
     * {
     *     scale: "minute",
     *     sign: 1,
     *     pattern: "in {0} minutes"
     * }
     * </pre>
     *
     * @param {string[]} aScales The scales for which the available patterns should be returned
     * @param {string} [sStyle="wide"] @since 1.32.10, 1.34.4 The style of the scale patterns. The valid values are "wide", "short" and "narrow".
     * @returns {object[]} An array of all relative time patterns
     * @public
     * @since 1.34
     */
    getRelativePatterns: function(aScales, sStyle) {
      if (sStyle === void 0) {
        sStyle = "wide";
      }
      assert_default(sStyle === "wide" || sStyle === "short" || sStyle === "narrow", "sStyle is only allowed to be set with 'wide', 'short' or 'narrow'");
      var aPatterns = [], aPluralCategories = this.getPluralCategories(), oScale, oTimeEntry, iValue, iSign;
      if (!aScales) {
        aScales = ["year", "month", "week", "day", "hour", "minute", "second"];
      }
      aScales.forEach((function(sScale) {
        oScale = this._get("dateFields", sScale + "-" + sStyle);
        for (var sEntry in oScale) {
          if (sEntry.indexOf("relative-type-") === 0) {
            iValue = parseInt(sEntry.substr(14));
            aPatterns.push({
              scale: sScale,
              value: iValue,
              pattern: oScale[sEntry]
            });
          } else if (sEntry.indexOf("relativeTime-type-") == 0) {
            oTimeEntry = oScale[sEntry];
            iSign = sEntry.substr(18) === "past" ? -1 : 1;
            aPluralCategories.forEach(function(sKey) {
              var sPattern = oTimeEntry["relativeTimePattern-count-" + sKey];
              if (sPattern) {
                aPatterns.push({
                  scale: sScale,
                  sign: iSign,
                  pattern: sPattern
                });
              }
            });
          }
        }
      }).bind(this));
      return aPatterns;
    },
    /**
     * Returns the relative format pattern with given scale (year, month, week, ...) and difference value.
     *
     * @param {string} sScale the scale the relative pattern is needed for
     * @param {int} iDiff the difference in the given scale unit
     * @param {boolean} [bFuture] whether a future or past pattern should be used
     * @param {string} [sStyle="wide"] @since 1.32.10, 1.34.4 the style of the pattern. The valid values are "wide", "short" and "narrow"
     * @returns {string} the relative format pattern
     * @public
     * @since 1.34
     */
    getRelativePattern: function(sScale, iDiff, bFuture, sStyle) {
      var sPattern, oTypes, sKey, sPluralCategory;
      if (typeof bFuture === "string") {
        sStyle = bFuture;
        bFuture = void 0;
      }
      if (bFuture === void 0) {
        bFuture = iDiff > 0;
      }
      if (sStyle === void 0) {
        sStyle = "wide";
      }
      assert_default(sStyle === "wide" || sStyle === "short" || sStyle === "narrow", "sStyle is only allowed to be set with 'wide', 'short' or 'narrow'");
      sKey = sScale + "-" + sStyle;
      if (iDiff === 0 || iDiff === -2 || iDiff === 2) {
        sPattern = this._get("dateFields", sKey, "relative-type-" + iDiff);
      }
      if (!sPattern) {
        oTypes = this._get("dateFields", sKey, "relativeTime-type-" + (bFuture ? "future" : "past"));
        sPluralCategory = this.getPluralCategory(Math.abs(iDiff).toString());
        sPattern = oTypes["relativeTimePattern-count-" + sPluralCategory];
      }
      return sPattern;
    },
    /**
     * Returns the relative resource pattern with unit 'second' (like now, "in {0} seconds", "{0} seconds ago" under locale 'en') based on the given
     * difference value (0 means now, positive value means in the future and negative value means in the past).
     *
     * @param {int} iDiff the difference in seconds
     * @param {string} [sStyle="wide"] @since 1.32.10, 1.34.4 the style of the pattern. The valid values are "wide", "short" and "narrow"
     * @returns {string} the relative resource pattern in unit 'second'
     * @public
     * @since 1.31.0
     */
    getRelativeSecond: function(iDiff, sStyle) {
      return this.getRelativePattern("second", iDiff, sStyle);
    },
    /**
     * Returns the relative resource pattern with unit 'minute' (like "in {0} minute(s)", "{0} minute(s) ago" under locale 'en') based on the given
     * difference value (positive value means in the future and negative value means in the past).
     *
     * There's no pattern defined for 0 difference and the function returns null if 0 is given. In the 0 difference case, you can use the getRelativeSecond
     * function to format the difference using unit 'second'.
     *
     * @param {int} iDiff the difference in minutes
     * @param {string} [sStyle="wide"] @since 1.32.10, 1.34.4 the style of the pattern. The valid values are "wide", "short" and "narrow"
     * @returns {string|null} the relative resource pattern in unit 'minute'. The method returns null if 0 is given as parameter.
     * @public
     * @since 1.31.0
     */
    getRelativeMinute: function(iDiff, sStyle) {
      if (iDiff == 0) {
        return null;
      }
      return this.getRelativePattern("minute", iDiff, sStyle);
    },
    /**
     * Returns the relative resource pattern with unit 'hour' (like "in {0} hour(s)", "{0} hour(s) ago" under locale 'en') based on the given
     * difference value (positive value means in the future and negative value means in the past).
     *
     * There's no pattern defined for 0 difference and the function returns null if 0 is given. In the 0 difference case, you can use the getRelativeMinute or getRelativeSecond
     * function to format the difference using unit 'minute' or 'second'.
     *
     * @param {int} iDiff the difference in hours
     * @param {string} [sStyle="wide"] @since 1.32.10, 1.34.4 the style of the pattern. The valid values are "wide", "short" and "narrow"
     * @returns {string|null} the relative resource pattern in unit 'hour'. The method returns null if 0 is given as parameter.
     * @public
     * @since 1.31.0
     */
    getRelativeHour: function(iDiff, sStyle) {
      if (iDiff == 0) {
        return null;
      }
      return this.getRelativePattern("hour", iDiff, sStyle);
    },
    /**
     * Returns the relative day resource pattern (like "Today", "Yesterday", "{0} days ago") based on the given
     * difference of days (0 means today, 1 means tomorrow, -1 means yesterday, ...).
     *
     * @param {int} iDiff the difference in days
     * @param {string} [sStyle="wide"] @since 1.32.10, 1.34.4 the style of the pattern. The valid values are "wide", "short" and "narrow"
     * @returns {string} the relative day resource pattern
     * @public
     * @since 1.25.0
     */
    getRelativeDay: function(iDiff, sStyle) {
      return this.getRelativePattern("day", iDiff, sStyle);
    },
    /**
     * Returns the relative week resource pattern (like "This week", "Last week", "{0} weeks ago") based on the given
     * difference of weeks (0 means this week, 1 means next week, -1 means last week, ...).
     *
     * @param {int} iDiff the difference in weeks
     * @param {string} [sStyle="wide"] @since 1.32.10, 1.34.4 the style of the pattern. The valid values are "wide", "short" and "narrow"
     * @returns {string} the relative week resource pattern
     * @public
     * @since 1.31.0
     */
    getRelativeWeek: function(iDiff, sStyle) {
      return this.getRelativePattern("week", iDiff, sStyle);
    },
    /**
     * Returns the relative month resource pattern (like "This month", "Last month", "{0} months ago") based on the given
     * difference of months (0 means this month, 1 means next month, -1 means last month, ...).
     *
     * @param {int} iDiff the difference in months
     * @param {string} [sStyle="wide"] @since 1.32.10, 1.34.4 the style of the pattern. The valid values are "wide", "short" and "narrow"
     * @returns {string} the relative month resource pattern
     * @public
     * @since 1.25.0
     */
    getRelativeMonth: function(iDiff, sStyle) {
      return this.getRelativePattern("month", iDiff, sStyle);
    },
    /**
     * Returns the display name for a time unit (second, minute, hour, day, week, month, year).
     *
     * @param {string} sType Type (second, minute, hour, day, week, month, year)
     * @param {string} [sStyle="wide"] @since 1.32.10, 1.34.4 the style of the pattern. The valid values are "wide", "short" and "narrow"
     * returns {string} display name
     * @public
     * @since 1.34.0
     */
    getDisplayName: function(sType, sStyle) {
      assert_default(sType == "second" || sType == "minute" || sType == "hour" || sType == "zone" || sType == "day" || sType == "weekday" || sType == "week" || sType == "month" || sType == "quarter" || sType == "year" || sType == "era", "sType must be second, minute, hour, zone, day, weekday, week, month, quarter, year, era");
      if (sStyle === void 0) {
        sStyle = "wide";
      }
      assert_default(sStyle === "wide" || sStyle === "short" || sStyle === "narrow", "sStyle is only allowed to be set with 'wide', 'short' or 'narrow'");
      var aSingleFormFields = ["era", "weekday", "zone"], sKey = aSingleFormFields.indexOf(sType) === -1 ? sType + "-" + sStyle : sType;
      return this._get("dateFields", sKey, "displayName");
    },
    /**
     * Returns the relative year resource pattern (like "This year", "Last year", "{0} year ago") based on the given
     * difference of years (0 means this year, 1 means next year, -1 means last year, ...).
     *
     * @param {int} iDiff the difference in years
     * @param {string} [sStyle="wide"] @since 1.32.10, 1.34.4 the style of the pattern. The valid values are "wide", "short" and "narrow"
     * @returns {string} the relative year resource pattern
     * @public
     * @since 1.25.0
     */
    getRelativeYear: function(iDiff, sStyle) {
      return this.getRelativePattern("year", iDiff, sStyle);
    },
    /**
     * Returns the short decimal formats (like 1K, 1M....).
     *
     * @param {string} sStyle short or long
     * @param {string} sNumber 1000, 10000 ...
     * @param {string} sPlural one or other (if not exists other is used)
     * @returns {string} decimal format
     * @public
     * @since 1.25.0
     */
    getDecimalFormat: function(sStyle, sNumber, sPlural) {
      var sFormat;
      var oFormats;
      switch (sStyle) {
        case "long":
          oFormats = this._get("decimalFormat-long");
          break;
        default:
          oFormats = this._get("decimalFormat-short");
          break;
      }
      if (oFormats) {
        var sName = sNumber + "-" + sPlural;
        sFormat = oFormats[sName];
        if (!sFormat) {
          sName = sNumber + "-other";
          sFormat = oFormats[sName];
        }
      }
      return sFormat;
    },
    /**
     * Returns the short currency formats (like 1K USD, 1M USD....).
     *
     * @param {string} sStyle short
     * @param {string} sNumber 1000, 10000 ...
     * @param {string} sPlural one or other (if not exists other is used)
     * @returns {string} decimal format
     * @public
     * @since 1.51.0
     */
    getCurrencyFormat: function(sStyle, sNumber, sPlural) {
      var sFormat;
      var oFormats = this._get("currencyFormat-" + sStyle);
      if (!oFormats) {
        if (sStyle === "sap-short") {
          throw new Error('Failed to get CLDR data for property "currencyFormat-sap-short"');
        }
        oFormats = this._get("currencyFormat-short");
      }
      if (oFormats) {
        var sName = sNumber + "-" + sPlural;
        sFormat = oFormats[sName];
        if (!sFormat) {
          sName = sNumber + "-other";
          sFormat = oFormats[sName];
        }
      }
      return sFormat;
    },
    /**
     * Returns a map containing patterns for formatting lists
     *
     *@param {string} [sType='standard'] The type of the list pattern. It can be 'standard' or 'or'.
     *@param {string} [sStyle='wide'] The style of the list pattern. It can be 'wide' or 'short'.
    * @return {object} Map with list patterns
     */
    getListFormat: function(sType, sStyle) {
      var oFormats = this._get("listPattern-" + (sType || "standard") + "-" + (sStyle || "wide"));
      if (oFormats) {
        return oFormats;
      }
      return {};
    },
    /**
     * Retrieves the unit format pattern for a specific unit name considering the unit mappings.
     * @param {string} sUnit unit name, e.g. "duration-hour" or "my"
     * @return {object} The unit format configuration for the given unit name
     * @public
     * @since 1.54
     * @see sap.ui.core.LocaleData#getUnitFromMapping
     */
    getResolvedUnitFormat: function(sUnit) {
      sUnit = this.getUnitFromMapping(sUnit) || sUnit;
      return this.getUnitFormat(sUnit);
    },
    /**
     * Retrieves the unit format pattern for a specific unit name.
     *
     * Note: Does not take unit mapping into consideration.
     * @param {string} sUnit unit name, e.g. "duration-hour"
     * @return {object} The unit format configuration for the given unit name
     * @public
     * @since 1.54
     */
    getUnitFormat: function(sUnit) {
      var oResult = this._get("units", "short", sUnit);
      if (!oResult && mLegacyUnit2CurrentUnit[sUnit]) {
        oResult = this._get("units", "short", mLegacyUnit2CurrentUnit[sUnit]);
      }
      return oResult;
    },
    /**
     * Retrieves all unit format patterns merged.
     *
     * Note: Does not take unit mapping into consideration.
     * @return {object} The unit format patterns
     * @public
     * @since 1.54
     */
    getUnitFormats: function() {
      return this._getMerged("units", "short");
    },
    /**
     * Looks up the unit from defined unit mapping.
     * E.g. for defined unit mapping
     * <code>
     * {
     *  "my": "my-custom-unit",
     *  "cm": "length-centimeter"
     * }
     * </code>
     *
     * Call:
     * <code>getUnitFromMapping("my")</code> would result in <code>"my-custom-unit"</code>
     * @param {string} sMapping mapping identifier
     * @return {string} unit from the mapping
     * @public
     * @since 1.54
     */
    getUnitFromMapping: function(sMapping) {
      return this._get("unitMappings", sMapping);
    },
    /**
     * Returns array of eras.
     *
     * @param {string} sWidth the style of the era name. It can be 'wide', 'abbreviated' or 'narrow'
     * @param {sap.ui.core.CalendarType} [sCalendarType] the type of calendar
     * @return {array} the array of eras
     * @public
     * @since 1.32.0
     */
    getEras: function(sWidth, sCalendarType) {
      assert_default(sWidth == "wide" || sWidth == "abbreviated" || sWidth == "narrow", "sWidth must be wide, abbreviate or narrow");
      var oEras = this._get(getCLDRCalendarName(sCalendarType), "era-" + sWidth), aEras = [];
      for (var i in oEras) {
        aEras[parseInt(i)] = oEras[i];
      }
      return aEras;
    },
    /**
     * Returns the map of era IDs to era dates.
     *
     * @param {sap.ui.core.CalendarType} [sCalendarType] the type of calendar
     * @return {array} the array of eras containing objects with either an _end or _start property with a date
     * @public
     * @since 1.32.0
     */
    getEraDates: function(sCalendarType) {
      var oEraDates = this._get("eras-" + sCalendarType.toLowerCase()), aEraDates = [];
      for (var i in oEraDates) {
        aEraDates[parseInt(i)] = oEraDates[i];
      }
      return aEraDates;
    },
    /**
     * Returns the defined pattern for representing the calendar week number.
     *
     * @param {string} sStyle the style of the pattern. It can only be either "wide" or "narrow".
     * @param {int} iWeekNumber the week number
     * @return {string} the week number string
     *
     * @public
     * @since 1.32.0
     */
    getCalendarWeek: function(sStyle, iWeekNumber) {
      assert_default(sStyle == "wide" || sStyle == "narrow", "sStyle must be wide or narrow");
      var oMessageBundle = Core_default.getLibraryResourceBundle("sap.ui.core", this.oLocale.toString()), sKey = "date.week.calendarweek." + sStyle;
      return oMessageBundle.getText(sKey, iWeekNumber ? [iWeekNumber] : void 0);
    },
    /**
     * Whether 1 January is the first day of the first calendar week.
     * This is the definition of the calendar week in the US.
     *
     * @return {boolean} true if the first week of the year starts with 1 January.
     * @public
     * @since 1.92.0
     */
    firstDayStartsFirstWeek: function() {
      return this.oLocale.getLanguage() === "en" && this.oLocale.getRegion() === "US";
    },
    /**
     * Returns the preferred calendar type for the current locale which exists in {@link sap.ui.core.CalendarType}
     *
     * @returns {sap.ui.core.CalendarType} the preferred calendar type
     * @public
     * @since 1.28.6
     */
    getPreferredCalendarType: function() {
      var sCalendarName, sType, i, aCalendars = this._get("calendarPreference") || [];
      for (i = 0; i < aCalendars.length; i++) {
        sCalendarName = aCalendars[i].split("-")[0];
        for (sType in CalendarType_default3) {
          if (sCalendarName === sType.toLowerCase()) {
            return sType;
          }
        }
      }
      return CalendarType_default3.Gregorian;
    },
    /**
     * Returns the preferred hour pattern symbol (h for 12, H for 24 hours) for the current locale.
     *
     * @returns {string} the preferred hour symbol
     * @public
     * @since 1.34
     */
    getPreferredHourSymbol: function() {
      return this._get("timeData", "_preferred");
    },
    /**
     * Returns an array of all plural categories available in this language.
     *
     * @returns {array} The array of plural categories
     * @public
     * @since 1.50
     */
    getPluralCategories: function() {
      var oPlurals = this._get("plurals"), aCategories = Object.keys(oPlurals);
      aCategories.push("other");
      return aCategories;
    },
    /**
     * Returns the plural category (zero, one, two, few, many or other) for the given number value.
     * The number must be passed as an unformatted number string with dot as decimal
     * separator (for example "12345.67"). To determine the correct plural category, it
     * is also necessary to keep the same number of decimal digits as given in the formatted
     * output string. For example "1" and "1.0" could be in different plural categories as
     * the number of decimal digits is different.
     *
     * Compact numbers (for example in "short" format) must be provided in the
     * locale-independent CLDR compact notation. This notation uses the plural rule operand "c"
     * for the compact decimal exponent, for example "1.2c3" for "1.2K" (1200) or "4c6" for
     * "4M" (4000000).
     *
     * Note that the operand "e" is deprecated, but is a synonym corresponding to the CLDR
     * specification for "c" and may be redefined in the future.
     *
     * @param {string|number} vNumber The number to find the plural category for
     * @returns {string} The plural category
     * @public
     * @since 1.50
     */
    getPluralCategory: function(vNumber) {
      var sNumber = typeof vNumber === "number" ? vNumber.toString() : vNumber, oPlurals = this._get("plurals");
      if (!this._pluralTest) {
        this._pluralTest = {};
      }
      for (var sCategory in oPlurals) {
        var fnTest = this._pluralTest[sCategory];
        if (!fnTest) {
          fnTest = this._parsePluralRule(oPlurals[sCategory]);
          this._pluralTest[sCategory] = fnTest;
        }
        if (fnTest(sNumber).bMatch) {
          return sCategory;
        }
      }
      return "other";
    },
    /**
     * Parses a language plural rule as specified in
     * https://unicode.org/reports/tr35/tr35-numbers.html#table-plural-operand-meanings
     *
     * @param {string} sRule The plural rule as a string
     * @returns {function(string)} A function to determine for a number given as string parameter if it matches the
     *   plural rule.
     *
     * @private
     */
    _parsePluralRule: function(sRule) {
      var OP_OR = "or", OP_AND = "and", OP_MOD = "%", OP_EQ = "=", OP_NEQ = "!=", OPD_N = "n", OPD_I = "i", OPD_F = "f", OPD_T = "t", OPD_V = "v", OPD_W = "w", OPD_C = "c", OPD_E = "e", RANGE = "..", SEP = ",";
      var i = 0, aTokens;
      aTokens = sRule.split(" ");
      function accept(sToken) {
        if (aTokens[i] === sToken) {
          i++;
          return true;
        }
        return false;
      }
      function consume() {
        var sToken = aTokens[i];
        i++;
        return sToken;
      }
      function or_condition() {
        var fnAnd, fnOr2;
        fnAnd = and_condition();
        if (accept(OP_OR)) {
          fnOr2 = or_condition();
          return function(o) {
            return fnAnd(o) || fnOr2(o);
          };
        }
        return fnAnd;
      }
      function and_condition() {
        var fnRelation, fnAnd;
        fnRelation = relation();
        if (accept(OP_AND)) {
          fnAnd = and_condition();
          return function(o) {
            return fnRelation(o) && fnAnd(o);
          };
        }
        return fnRelation;
      }
      function relation() {
        var fnExpr, fnRangeList, bEq;
        fnExpr = expr();
        if (accept(OP_EQ)) {
          bEq = true;
        } else if (accept(OP_NEQ)) {
          bEq = false;
        } else {
          throw new Error("Expected '=' or '!='");
        }
        fnRangeList = range_list();
        if (bEq) {
          return function(o) {
            return fnRangeList(o).indexOf(fnExpr(o)) >= 0;
          };
        } else {
          return function(o) {
            return fnRangeList(o).indexOf(fnExpr(o)) === -1;
          };
        }
      }
      function expr() {
        var fnOperand;
        fnOperand = operand();
        if (accept(OP_MOD)) {
          var iDivisor = parseInt(consume());
          return function(o) {
            return fnOperand(o) % iDivisor;
          };
        }
        return fnOperand;
      }
      function operand() {
        if (accept(OPD_N)) {
          return function(o) {
            return o.n;
          };
        } else if (accept(OPD_I)) {
          return function(o) {
            return o.i;
          };
        } else if (accept(OPD_F)) {
          return function(o) {
            return o.f;
          };
        } else if (accept(OPD_T)) {
          return function(o) {
            return o.t;
          };
        } else if (accept(OPD_V)) {
          return function(o) {
            return o.v;
          };
        } else if (accept(OPD_W)) {
          return function(o) {
            return o.w;
          };
        } else if (accept(OPD_C)) {
          return function(o) {
            return o.c;
          };
        } else if (accept(OPD_E)) {
          return function(o) {
            return o.c;
          };
        } else {
          throw new Error("Unknown operand: " + consume());
        }
      }
      function range_list() {
        var aValues = [], sRangeList = consume(), aParts = sRangeList.split(SEP), aRange, iFrom, iTo;
        aParts.forEach(function(sPart) {
          aRange = sPart.split(RANGE);
          if (aRange.length === 1) {
            aValues.push(parseInt(sPart));
          } else {
            iFrom = parseInt(aRange[0]);
            iTo = parseInt(aRange[1]);
            for (var i2 = iFrom; i2 <= iTo; i2++) {
              aValues.push(i2);
            }
          }
        });
        return function(o) {
          return aValues;
        };
      }
      var fnOr = or_condition();
      if (i != aTokens.length) {
        throw new Error("Not completely parsed");
      }
      return function(sValue) {
        var iDotPos, iExponent, iExponentPos, sFraction, sFractionNoZeros, sInteger, o;
        sValue = sValue.replace(rCIgnoreCase, "e");
        iExponentPos = sValue.search(rEIgnoreCase);
        iExponent = iExponentPos < 0 ? 0 : parseInt(sValue.slice(iExponentPos + 1));
        sValue = LocaleData.convertToDecimal(sValue);
        iDotPos = sValue.indexOf(".");
        if (iDotPos === -1) {
          sInteger = sValue;
          sFraction = "";
          sFractionNoZeros = "";
        } else {
          sInteger = sValue.slice(0, iDotPos);
          sFraction = sValue.slice(iDotPos + 1);
          sFractionNoZeros = sFraction.replace(rTrailingZeroes, "");
        }
        o = {
          n: parseFloat(sValue),
          i: parseInt(sInteger),
          v: sFraction.length,
          w: sFractionNoZeros.length,
          f: sFraction === "" ? 0 : parseInt(sFraction),
          t: sFractionNoZeros === "" ? 0 : parseInt(sFractionNoZeros),
          c: iExponent
        };
        return {
          bMatch: fnOr(o),
          oOperands: o
        };
      };
    }
  }
);
LocaleData.convertToDecimal = function(vValue) {
  var iIntegerLength, iExponent, iFractionLength, bNegative, iNewIntegerLength, aResult, sValue = String(vValue);
  if (!sValue.includes("e") && !sValue.includes("E")) {
    return sValue;
  }
  aResult = sValue.match(rNumberInScientificNotation);
  bNegative = aResult[1] === "-";
  sValue = aResult[2].replace(".", "");
  iIntegerLength = aResult[3] ? aResult[3].length : 0;
  iFractionLength = aResult[4] ? aResult[4].length : 0;
  iExponent = parseInt(aResult[5]);
  iNewIntegerLength = iIntegerLength + iExponent;
  if (iExponent > 0) {
    sValue = iExponent < iFractionLength ? sValue.slice(0, iNewIntegerLength) + "." + sValue.slice(iNewIntegerLength) : sValue = sValue.padEnd(iNewIntegerLength, "0");
  } else {
    sValue = -iExponent < iIntegerLength ? sValue = sValue.slice(0, iNewIntegerLength) + "." + sValue.slice(iNewIntegerLength) : sValue = "0." + sValue.padStart(iFractionLength - iExponent, "0");
  }
  if (bNegative) {
    sValue = "-" + sValue;
  }
  return sValue;
};
var mCLDRSymbolGroups = {
  "Era": {
    field: "era",
    index: 0
  },
  "Year": {
    field: "year",
    index: 1
  },
  "Quarter": {
    field: "quarter",
    index: 2
  },
  "Month": {
    field: "month",
    index: 3
  },
  "Week": {
    field: "week",
    index: 4
  },
  "Day-Of-Week": {
    field: "weekday",
    index: 5
  },
  "Day": {
    field: "day",
    index: 6
  },
  "DayPeriod": {
    field: "hour",
    index: 7,
    diffOnly: true
  },
  "Hour": {
    field: "hour",
    index: 8
  },
  "Minute": {
    field: "minute",
    index: 9
  },
  "Second": {
    field: "second",
    index: 10
  },
  "Timezone": {
    field: "zone",
    index: 11
  }
};
var mCLDRSymbols = {
  "G": {
    group: "Era",
    match: "Era",
    numericCeiling: 1
  },
  "y": {
    group: "Year",
    match: "Year",
    numericCeiling: 100
  },
  "Y": {
    group: "Year",
    match: "Year",
    numericCeiling: 100
  },
  "Q": {
    group: "Quarter",
    match: "Quarter",
    numericCeiling: 3
  },
  "q": {
    group: "Quarter",
    match: "Quarter",
    numericCeiling: 3
  },
  "M": {
    group: "Month",
    match: "Month",
    numericCeiling: 3
  },
  "L": {
    group: "Month",
    match: "Month",
    numericCeiling: 3
  },
  "w": {
    group: "Week",
    match: "Week",
    numericCeiling: 100
  },
  "W": {
    group: "Week",
    match: "Week",
    numericCeiling: 100
  },
  "d": {
    group: "Day",
    match: "Day",
    numericCeiling: 100
  },
  "D": {
    group: "Day",
    match: "Day",
    numericCeiling: 100
  },
  "E": {
    group: "Day-Of-Week",
    match: "Day-Of-Week",
    numericCeiling: 1
  },
  "e": {
    group: "Day-Of-Week",
    match: "Day-Of-Week",
    numericCeiling: 3
  },
  "c": {
    group: "Day-Of-Week",
    match: "Day-Of-Week",
    numericCeiling: 2
  },
  "h": {
    group: "Hour",
    match: "Hour12",
    numericCeiling: 100
  },
  "H": {
    group: "Hour",
    match: "Hour24",
    numericCeiling: 100
  },
  "k": {
    group: "Hour",
    match: "Hour24",
    numericCeiling: 100
  },
  "K": {
    group: "Hour",
    match: "Hour12",
    numericCeiling: 100
  },
  "m": {
    group: "Minute",
    match: "Minute",
    numericCeiling: 100
  },
  "s": {
    group: "Second",
    match: "Second",
    numericCeiling: 100
  },
  "z": {
    group: "Timezone",
    match: "Timezone",
    numericCeiling: 1
  },
  "Z": {
    group: "Timezone",
    match: "Timezone",
    numericCeiling: 1
  },
  "O": {
    group: "Timezone",
    match: "Timezone",
    numericCeiling: 1
  },
  "v": {
    group: "Timezone",
    match: "Timezone",
    numericCeiling: 1
  },
  "V": {
    group: "Timezone",
    match: "Timezone",
    numericCeiling: 1
  },
  "X": {
    group: "Timezone",
    match: "Timezone",
    numericCeiling: 1
  },
  "x": {
    group: "Timezone",
    match: "Timezone",
    numericCeiling: 1
  },
  "S": {
    group: "Other",
    numericCeiling: 100
  },
  "u": {
    group: "Other",
    numericCeiling: 100
  },
  "U": {
    group: "Other",
    numericCeiling: 1
  },
  "r": {
    group: "Other",
    numericCeiling: 100
  },
  "F": {
    group: "Other",
    numericCeiling: 100
  },
  "g": {
    group: "Other",
    numericCeiling: 100
  },
  "a": {
    group: "DayPeriod",
    numericCeiling: 1
  },
  "b": {
    group: "Other",
    numericCeiling: 1
  },
  "B": {
    group: "Other",
    numericCeiling: 1
  },
  "A": {
    group: "Other",
    numericCeiling: 100
  }
};
function getDesigntimePropertyAsArray(sValue) {
  var m = /\$([-a-z0-9A-Z._]+)(?::([^$]*))?\$/.exec(sValue);
  return m && m[2] ? m[2].split(/,/) : null;
}
var _cldrLocales = getDesigntimePropertyAsArray("$cldr-locales:ar,ar_EG,ar_SA,bg,ca,cnr,cy,cs,da,de,de_AT,de_CH,el,el_CY,en,en_AU,en_GB,en_HK,en_IE,en_IN,en_NZ,en_PG,en_SG,en_ZA,es,es_AR,es_BO,es_CL,es_CO,es_MX,es_PE,es_UY,es_VE,et,fa,fi,fr,fr_BE,fr_CA,fr_CH,fr_LU,he,hi,hr,hu,id,it,it_CH,ja,kk,ko,lt,lv,mk,ms,nb,nl,nl_BE,pl,pt,pt_PT,ro,ru,ru_UA,sk,sl,sr,sr_Latn,sv,th,tr,uk,vi,zh_CN,zh_HK,zh_SG,zh_TW$");
var M_SUPPORTED_LOCALES = function() {
  var LOCALES = _cldrLocales, result = {}, i;
  if (LOCALES) {
    for (i = 0; i < LOCALES.length; i++) {
      result[LOCALES[i]] = true;
    }
  }
  return result;
}();
var mLocaleDatas = {};
function _resolveTimezoneTranslationStructure(oNode, sKey, oResult, aParentTranslations) {
  aParentTranslations = aParentTranslations ? aParentTranslations.slice() : [];
  oResult = oResult || {};
  sKey = sKey || "";
  Object.keys(oNode).forEach(function(sChildKey) {
    var vChildNode = oNode[sChildKey];
    if (typeof vChildNode === "object") {
      var aParentTranslationForChild = aParentTranslations.slice();
      var sParent = vChildNode["_parent"];
      if (sParent) {
        aParentTranslationForChild.push(sParent);
      }
      _resolveTimezoneTranslationStructure(vChildNode, sKey + sChildKey + "/", oResult, aParentTranslationForChild);
    } else if (typeof vChildNode === "string" && sChildKey !== "_parent") {
      var sParents = aParentTranslations.length ? aParentTranslations.join(", ") + ", " : "";
      oResult[sKey + sChildKey] = sParents + vChildNode;
    }
  });
  return oResult;
}
function getCLDRCalendarName(sCalendarType) {
  if (!sCalendarType) {
    sCalendarType = Configuration_default.getCalendarType();
  }
  return "ca-" + sCalendarType.toLowerCase();
}
function getData(oLocale) {
  var sLanguage = oLocale.getLanguage() || "", sScript = oLocale.getScript() || "", sRegion = oLocale.getRegion() || "", mData;
  function merge(obj, fallbackObj) {
    var name, value, fallbackValue;
    if (!fallbackObj) {
      return;
    }
    for (name in fallbackObj) {
      if (fallbackObj.hasOwnProperty(name)) {
        value = obj[name];
        fallbackValue = fallbackObj[name];
        if (value === void 0) {
          obj[name] = fallbackValue;
        } else if (value === null) {
          delete obj[name];
        } else if (typeof value === "object" && typeof fallbackValue === "object" && !Array.isArray(value)) {
          merge(value, fallbackValue);
        }
      }
    }
  }
  function getOrLoad(sId2) {
    if (!mLocaleDatas[sId2] && (!M_SUPPORTED_LOCALES || M_SUPPORTED_LOCALES[sId2] === true)) {
      var data = mLocaleDatas[sId2] = LoaderExtensions_default.loadResource("sap/ui/core/cldr/" + sId2 + ".json", {
        dataType: "json",
        failOnError: false
      });
      if (data && data.__fallbackLocale) {
        merge(data, getOrLoad(data.__fallbackLocale));
        delete data.__fallbackLocale;
      }
    }
    return mLocaleDatas[sId2];
  }
  sLanguage = sLanguage && Localization_default.getModernLanguage(sLanguage) || sLanguage;
  if (sLanguage === "no") {
    sLanguage = "nb";
  }
  if (sLanguage === "zh" && !sRegion) {
    if (sScript === "Hans") {
      sRegion = "CN";
    } else if (sScript === "Hant") {
      sRegion = "TW";
    }
  }
  if (sLanguage === "sh" || sLanguage === "sr" && sScript === "Latn") {
    sLanguage = "sr_Latn";
  }
  var sId = sLanguage + "_" + sRegion;
  var sCLDRLocaleId = sId;
  if (sLanguage && sRegion) {
    mData = getOrLoad(sId);
  }
  if (!mData && sLanguage) {
    mData = getOrLoad(sLanguage);
    sCLDRLocaleId = sLanguage;
  }
  if (!mData) {
    mData = getOrLoad("en");
    sCLDRLocaleId = "en";
  }
  mLocaleDatas[sId] = mData;
  sCLDRLocaleId = sCLDRLocaleId.replace(/_/g, "-");
  return {
    mData,
    sCLDRLocaleId
  };
}
var CustomLocaleData = LocaleData.extend("sap.ui.core.CustomLocaleData", {
  constructor: function(oLocale) {
    LocaleData.apply(this, arguments);
    this.mCustomData = Configuration_default.getFormatSettings().getCustomLocaleData();
  },
  /**
   * Retrieves the value for the given arguments by checking first <code>mCustomData</code> and if not
   * found <code>mData</code>
   * @returns {*} value
   * @private
   */
  _get: function() {
    var aArguments = Array.prototype.slice.call(arguments), sCalendar, sKey;
    if (aArguments[0].indexOf("ca-") == 0) {
      sCalendar = aArguments[0];
      if (sCalendar == getCLDRCalendarName()) {
        aArguments = aArguments.slice(1);
      }
    }
    sKey = aArguments.join("-");
    var vValue = this.mCustomData[sKey];
    if (vValue == null) {
      vValue = this._getDeep(this.mCustomData, arguments);
      if (vValue == null) {
        vValue = this._getDeep(this.mData, arguments);
      }
    }
    return vValue;
  },
  /**
   * Retrieves merged object from <code>mData</code> extended with <code>mCustomData</code>.
   * This function merges the content of <code>mData</code> and <code>mCustomData</code> instead of returning one or the other like <code>_get()</code> does.
   *
   * Note: Properties defined in <code>mCustomData</code> overwrite the ones from <code>mData</code>.
   * @private
   * @return {object} merged object
   */
  _getMerged: function() {
    var mData = this._getDeep(this.mData, arguments);
    var mCustomData = this._getDeep(this.mCustomData, arguments);
    return extend_default({}, mData, mCustomData);
  },
  /**
   * Returns the first day of the week defined by the calendar week numbering algorithm
   * set in the configuration, see {@link sap.ui.core.Configuration#setCalendarWeekNumbering}.
   * If no specific calendar week numbering algorithm is configured the value set by
   * {@link sap.ui.core.Configuration#setFirstDayOfWeek} is returned. Otherwise the first day
   * of the week is determined by the current locale, see {@link sap.ui.core.LocaleData#getFirstDayOfWeek}.
   *
   * Days are encoded as integer where Sunday=0, Monday=1 etc.
   *
   * @returns {int} The first day of week
   * @override sap.ui.core.LocalData#getFirstDayOfWeek
   * @since 1.113.0
   */
  getFirstDayOfWeek: function() {
    var sCalendarWeekNumbering = Configuration_default.getCalendarWeekNumbering();
    if (sCalendarWeekNumbering === CalendarWeekNumbering_default2.Default) {
      return LocaleData.prototype.getFirstDayOfWeek.call(this);
    }
    return CalendarWeekNumbering_default2.getWeekConfigurationValues(sCalendarWeekNumbering).firstDayOfWeek;
  },
  /**
   * Returns the required minimal number of days for the first week of a year defined by the
   * calendar week numbering algorithm set in the configuration,
   * see {@link sap.ui.core.Configuration#setCalendarWeekNumbering}.
   * If no specific calendar week numbering algorithm is configured the required minimal number
   * of days for the first week of a year is determined by the current locale,
   * see {@link sap.ui.core.LocaleData#getMinimalDaysInFirstWeek}.
   *
   * @returns {int} The required minimal number of days for the first week of a year
   * @override sap.ui.core.LocalData#getMinimalDaysInFirstWeek
   * @since 1.113.0
   */
  getMinimalDaysInFirstWeek: function() {
    var sCalendarWeekNumbering = Configuration_default.getCalendarWeekNumbering();
    if (sCalendarWeekNumbering === CalendarWeekNumbering_default2.Default) {
      return LocaleData.prototype.getMinimalDaysInFirstWeek.call(this);
    }
    return CalendarWeekNumbering_default2.getWeekConfigurationValues(sCalendarWeekNumbering).minimalDaysInFirstWeek;
  }
});
LocaleData.getInstance = function(oLocale) {
  oLocale = Locale_default._getCoreLocale(oLocale);
  return oLocale.hasPrivateUseSubtag("sapufmt") ? new CustomLocaleData(oLocale) : new LocaleData(oLocale);
};
LocaleData._cldrLocales = _cldrLocales;
LocaleData._mTimezoneTranslations = {};
var rContainsSymbol = new RegExp("[" + Object.keys(mCLDRSymbols).join("") + "]");
var rTextWithOptionalSpacesAtStartAndEnd = /^(\s)?(.*?)(\s)?$/;
LocaleData._escapeIfNeeded = function(sValue) {
  if (sValue === void 0) {
    return "";
  }
  if (rContainsSymbol.test(sValue)) {
    return sValue.replace(rTextWithOptionalSpacesAtStartAndEnd, "$1'$2'$3");
  }
  return sValue;
};
var LocaleData_default = LocaleData;

// node_modules/@ui5/webcomponents-localization/dist/sap/ui/core/date/CalendarUtils.js
var CalendarUtils = {
  /**
   * Resolves calendar week configuration.
   *
   * Returns an object with the following fields:
   * <ul>
   *   <li><code>firstDayOfWeek</code>: specifies the first day of the week starting with
   *   <code>0</code> (which is Sunday)</li>
   *   <li><code>minimalDaysInFirstWeek</code>: minimal days at the beginning of the year
   *   which define the first calendar week</li>
   * </ul>
   *
   * @param {sap.ui.core.date.CalendarWeekNumbering} [sCalendarWeekNumbering]
   *   The calendar week numbering; if omitted, the calendar week numbering of the Configuration
   *   is used; see {@link sap.ui.core.Configuration#getCalendarWeekNumbering}. If this value is
   *   <code>Default</code> the returned calendar week configuration is derived from the given
   *   <code>oLocale</code>.
   * @param {sap.ui.core.Locale} [oLocale]
   *   The locale to use; if not provided, this falls back to the format locale from the
   *   Configuration; see {@link sap.ui.core.Configuration.FormatSettings#getFormatLocale}.
   *   Is only used when <code>sCalendarWeekNumbering</code> is set to <code>Default</code>.
   * @returns {{firstDayOfWeek: int, minimalDaysInFirstWeek: int}|undefined}
   *   The calendar week configuration, or <code>undefined<code> for an invalid value of
   *   <code>sap.ui.core.date.CalendarWeekNumbering</code>.
   * @public
   * @since 1.108.0
   */
  getWeekConfigurationValues: function(sCalendarWeekNumbering, oLocale) {
    var oLocaleData, oWeekConfigurationValues;
    if (!sCalendarWeekNumbering) {
      return CalendarUtils.getWeekConfigurationValues(Configuration_default.getCalendarWeekNumbering(), oLocale);
    }
    oWeekConfigurationValues = CalendarWeekNumbering_default2.getWeekConfigurationValues(sCalendarWeekNumbering);
    if (oWeekConfigurationValues) {
      return oWeekConfigurationValues;
    }
    if (sCalendarWeekNumbering === CalendarWeekNumbering_default2.Default) {
      oLocale = oLocale || Configuration_default.getFormatSettings().getFormatLocale();
      oLocaleData = LocaleData_default.getInstance(oLocale);
      return {
        firstDayOfWeek: oLocaleData.getFirstDayOfWeek(),
        minimalDaysInFirstWeek: oLocaleData.getMinimalDaysInFirstWeek()
      };
    }
    return void 0;
  }
};
var CalendarUtils_default = CalendarUtils;

// node_modules/@ui5/webcomponents-localization/dist/sap/ui/core/date/UI5Date.js
var aAllParts = ["year", "month", "day", "hour", "minute", "second", "fractionalSecond"];
var rIsUTCString = /Z|GMT|:.*[\+|\-]|^([\+|\-]\d{2})?\d{4}(-\d{2}){0,2}$/;
var aWeekday = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
var aMonths = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var mWeekdayToDay = {
  Sun: 0,
  Mon: 1,
  Tue: 2,
  Wed: 3,
  Thu: 4,
  Fri: 5,
  Sat: 6
};
function addLeadingZeros(iValue, iLength) {
  return (iValue < 0 ? "-" : "") + Math.abs(iValue).toString().padStart(iLength, "0");
}
function UI5Date(vDateParts, sTimezoneID) {
  var oDateInstance = UI5Date._createDateInstance(vDateParts);
  Object.defineProperties(this, {
    sTimezoneID: {
      value: sTimezoneID
    },
    oDate: {
      value: oDateInstance,
      writable: true
    },
    oDateParts: {
      value: void 0,
      writable: true
    }
  });
  if (isNaN(oDateInstance)) {
    return;
  }
  if (vDateParts.length > 1 || vDateParts.length === 1 && typeof vDateParts[0] === "string" && !rIsUTCString.test(vDateParts[0])) {
    this._setParts(
      aAllParts,
      // JavaScript Date parsed the arguments already in local browser time zone
      [oDateInstance.getFullYear(), oDateInstance.getMonth(), oDateInstance.getDate(), oDateInstance.getHours(), oDateInstance.getMinutes(), oDateInstance.getSeconds(), oDateInstance.getMilliseconds()]
    );
  }
}
UI5Date.prototype = Object.create(Date.prototype, {
  constructor: {
    value: Date
  }
});
UI5Date.prototype[Symbol.toStringTag] = "Date";
UI5Date.prototype._getPart = function(sPart) {
  var iResult;
  if (isNaN(this.oDate)) {
    return NaN;
  }
  this.oDateParts = this.oDateParts || TimezoneUtil_default._getParts(this.oDate, this.sTimezoneID);
  if (sPart === "weekday") {
    return mWeekdayToDay[this.oDateParts.weekday];
  }
  iResult = parseInt(this.oDateParts[sPart]);
  if (sPart === "month") {
    iResult -= 1;
  } else if (sPart === "year") {
    if (this.oDateParts.era === "B") {
      iResult = 1 - iResult;
    }
  }
  return iResult;
};
UI5Date.prototype._setParts = function(aParts, aValues) {
  var i, oCurrentDateParts, oNewDateAsUTCTimestamp, iNewTimestamp, sPart, vValue, oDateParts = {}, iMaxLength = Math.min(aParts.length, aValues.length);
  if (iMaxLength === 0) {
    return this.setTime(NaN);
  }
  for (i = 0; i < iMaxLength; i += 1) {
    vValue = parseInt(+aValues[i]);
    sPart = aParts[i];
    if (isNaN(vValue)) {
      return this.setTime(NaN);
    }
    if (sPart === "month") {
      vValue += 1;
    } else if (sPart === "year") {
      if (vValue <= 0) {
        vValue = 1 - vValue;
        oDateParts.era = "B";
      } else {
        oDateParts.era = "A";
      }
    }
    oDateParts[sPart] = vValue.toString();
  }
  if (this.oDateParts) {
    oCurrentDateParts = this.oDateParts;
  } else if (isNaN(this.oDate)) {
    oCurrentDateParts = {
      day: "1",
      fractionalSecond: "0",
      hour: "0",
      minute: "0",
      month: "1",
      second: "0"
    };
  } else {
    oCurrentDateParts = TimezoneUtil_default._getParts(this.oDate, this.sTimezoneID);
  }
  oDateParts = Object.assign({}, oCurrentDateParts, oDateParts);
  oNewDateAsUTCTimestamp = TimezoneUtil_default._getDateFromParts(oDateParts);
  if (isNaN(oNewDateAsUTCTimestamp)) {
    return this.setTime(NaN);
  }
  iNewTimestamp = oNewDateAsUTCTimestamp.getTime() + TimezoneUtil_default.calculateOffset(oNewDateAsUTCTimestamp, this.sTimezoneID) * 1e3;
  return this.setTime(iNewTimestamp);
};
UI5Date.prototype.clone = function() {
  return UI5Date.getInstance(this);
};
UI5Date.prototype.getDate = function() {
  return this._getPart("day");
};
UI5Date.prototype.getDay = function() {
  return this._getPart("weekday");
};
UI5Date.prototype.getFullYear = function() {
  return this._getPart("year");
};
UI5Date.prototype.getHours = function() {
  return this._getPart("hour");
};
UI5Date.prototype.getMilliseconds = function() {
  return this._getPart("fractionalSecond");
};
UI5Date.prototype.getMinutes = function() {
  return this._getPart("minute");
};
UI5Date.prototype.getMonth = function() {
  return this._getPart("month");
};
UI5Date.prototype.getSeconds = function() {
  return this._getPart("second");
};
UI5Date.prototype.getTimezoneOffset = function() {
  return TimezoneUtil_default.calculateOffset(this.oDate, this.sTimezoneID) / 60;
};
UI5Date.prototype.getYear = function() {
  return this._getPart("year") - 1900;
};
UI5Date.prototype.setDate = function(iDay) {
  return this._setParts(["day"], arguments);
};
UI5Date.prototype.setFullYear = function(iYear, iMonth, iDay) {
  return this._setParts(["year", "month", "day"], arguments);
};
UI5Date.prototype.setHours = function(iHours, iMinutes, iSeconds, iMilliseconds) {
  return this._setParts(["hour", "minute", "second", "fractionalSecond"], arguments);
};
UI5Date.prototype.setMilliseconds = function(iMilliseconds) {
  return this._setParts(["fractionalSecond"], arguments);
};
UI5Date.prototype.setMinutes = function(iMinutes, iSeconds, iMilliseconds) {
  return this._setParts(["minute", "second", "fractionalSecond"], arguments);
};
UI5Date.prototype.setMonth = function(iMonth, iDay) {
  return this._setParts(["month", "day"], arguments);
};
UI5Date.prototype.setSeconds = function(iSeconds, iMilliseconds) {
  return this._setParts(["second", "fractionalSecond"], arguments);
};
UI5Date.prototype.setTime = function(iTime) {
  this.oDateParts = void 0;
  return this.oDate.setTime(iTime);
};
UI5Date.prototype.setYear = function(iYear) {
  var iValue = parseInt(iYear);
  iValue = iValue < 0 || iValue > 99 ? iValue : iValue + 1900;
  return this._setParts(["year"], [iValue]);
};
UI5Date.prototype.toDateString = function() {
  if (isNaN(this.oDate)) {
    return this.oDate.toDateString();
  }
  return aWeekday[this.getDay()] + " " + aMonths[this.getMonth()] + " " + addLeadingZeros(this.getDate(), 2) + " " + addLeadingZeros(this.getFullYear(), 4);
};
UI5Date.prototype.toString = function() {
  if (isNaN(this.oDate)) {
    return this.oDate.toString();
  }
  return this.toDateString() + " " + this.toTimeString();
};
UI5Date.prototype.toTimeString = function() {
  var iHours, iMinutes, sSign, iTimeZoneOffset;
  if (isNaN(this.oDate)) {
    return this.oDate.toTimeString();
  }
  iTimeZoneOffset = this.getTimezoneOffset();
  sSign = iTimeZoneOffset > 0 ? "-" : "+";
  iHours = Math.floor(Math.abs(iTimeZoneOffset) / 60);
  iMinutes = Math.abs(iTimeZoneOffset) % 60;
  return addLeadingZeros(this.getHours(), 2) + ":" + addLeadingZeros(this.getMinutes(), 2) + ":" + addLeadingZeros(this.getSeconds(), 2) + " GMT" + sSign + addLeadingZeros(iHours, 2) + addLeadingZeros(iMinutes, 2);
};
["getTime", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "toGMTString", "toISOString", "toJSON", "toUTCString", "valueOf"].forEach(function(sMethod) {
  UI5Date.prototype[sMethod] = function() {
    return this.oDate[sMethod].apply(this.oDate, arguments);
  };
});
["toLocaleDateString", "toLocaleString", "toLocaleTimeString"].forEach(function(sMethod) {
  UI5Date.prototype[sMethod] = function(sLocale, oOptions) {
    return this.oDate[sMethod](sLocale || Configuration_default.getLanguageTag(), Object.assign({
      timeZone: this.sTimezoneID
    }, oOptions));
  };
});
["setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds"].forEach(function(sMethod) {
  UI5Date.prototype[sMethod] = function() {
    this.oDateParts = void 0;
    return this.oDate[sMethod].apply(this.oDate, arguments);
  };
});
UI5Date._createDateInstance = function(vParts) {
  if (vParts[0] instanceof Date) {
    vParts[0] = vParts[0].valueOf();
  }
  return new (Function.prototype.bind.apply(Date, [].concat.apply([null], vParts)))();
};
UI5Date.getInstance = function() {
  var sTimezone = Configuration_default.getTimezone();
  if (sTimezone !== TimezoneUtil_default.getLocalTimezone()) {
    return new UI5Date(arguments, sTimezone);
  }
  return UI5Date._createDateInstance(arguments);
};
UI5Date.checkDate = function(oDate) {
  if (isNaN(oDate.getTime())) {
    throw new Error("The given Date is not valid");
  }
  if (!(oDate instanceof UI5Date) && Configuration_default.getTimezone() !== TimezoneUtil_default.getLocalTimezone()) {
    throw new Error("Configured time zone requires the parameter 'oDate' to be an instance of sap.ui.core.date.UI5Date");
  }
};
var UI5Date_default = UI5Date;

// node_modules/@ui5/webcomponents-localization/dist/sap/ui/core/date/UniversalDate.js
var UniversalDate = Object_default.extend(
  "sap.ui.core.date.UniversalDate",
  /** @lends sap.ui.core.date.UniversalDate.prototype */
  {
    constructor: function() {
      var clDate = UniversalDate.getClass();
      return this.createDate(clDate, arguments);
    }
  }
);
UniversalDate.UTC = function() {
  var clDate = UniversalDate.getClass();
  return clDate.UTC.apply(clDate, arguments);
};
UniversalDate.now = function() {
  return Date.now();
};
UniversalDate.prototype.createDate = function(clDate, aArgs) {
  if (clDate === Date) {
    return UI5Date_default.getInstance.apply(null, aArgs);
  }
  switch (aArgs.length) {
    case 0:
      return new clDate();
    case 1:
      return new clDate(aArgs[0] instanceof Date ? aArgs[0].getTime() : aArgs[0]);
    case 2:
      return new clDate(aArgs[0], aArgs[1]);
    case 3:
      return new clDate(aArgs[0], aArgs[1], aArgs[2]);
    case 4:
      return new clDate(aArgs[0], aArgs[1], aArgs[2], aArgs[3]);
    case 5:
      return new clDate(aArgs[0], aArgs[1], aArgs[2], aArgs[3], aArgs[4]);
    case 6:
      return new clDate(aArgs[0], aArgs[1], aArgs[2], aArgs[3], aArgs[4], aArgs[5]);
    case 7:
      return new clDate(aArgs[0], aArgs[1], aArgs[2], aArgs[3], aArgs[4], aArgs[5], aArgs[6]);
  }
};
UniversalDate.getInstance = function(oDate, sCalendarType) {
  var clDate, oInstance;
  if (oDate instanceof UniversalDate) {
    oDate = oDate.getJSDate();
  }
  if (oDate && isNaN(oDate.getTime())) {
    throw new Error("The given date object is invalid");
  }
  if (!sCalendarType) {
    sCalendarType = Configuration_default.getCalendarType();
  }
  clDate = UniversalDate.getClass(sCalendarType);
  oInstance = Object.create(clDate.prototype);
  oInstance.oDate = oDate ? UI5Date_default.getInstance(oDate) : UI5Date_default.getInstance();
  oInstance.sCalendarType = sCalendarType;
  return oInstance;
};
UniversalDate.getClass = function(sCalendarType) {
  if (!sCalendarType) {
    sCalendarType = Configuration_default.getCalendarType();
  }
  return Calendars_default.get(sCalendarType);
};
["getDate", "getMonth", "getFullYear", "getYear", "getDay", "getHours", "getMinutes", "getSeconds", "getMilliseconds", "getUTCDate", "getUTCMonth", "getUTCFullYear", "getUTCDay", "getUTCHours", "getUTCMinutes", "getUTCSeconds", "getUTCMilliseconds", "getTime", "valueOf", "getTimezoneOffset", "toString", "toDateString", "setDate", "setFullYear", "setYear", "setMonth", "setHours", "setMinutes", "setSeconds", "setMilliseconds", "setUTCDate", "setUTCFullYear", "setUTCMonth", "setUTCHours", "setUTCMinutes", "setUTCSeconds", "setUTCMilliseconds"].forEach(function(sName) {
  UniversalDate.prototype[sName] = function() {
    return this.oDate[sName].apply(this.oDate, arguments);
  };
});
UniversalDate.prototype.getJSDate = function() {
  return this.oDate;
};
UniversalDate.prototype.getCalendarType = function() {
  return this.sCalendarType;
};
UniversalDate.prototype.getEra = function() {
  return UniversalDate.getEraByDate(this.sCalendarType, this.oDate.getFullYear(), this.oDate.getMonth(), this.oDate.getDate());
};
UniversalDate.prototype.setEra = function(iEra) {
};
UniversalDate.prototype.getUTCEra = function() {
  return UniversalDate.getEraByDate(this.sCalendarType, this.oDate.getUTCFullYear(), this.oDate.getUTCMonth(), this.oDate.getUTCDate());
};
UniversalDate.prototype.setUTCEra = function(iEra) {
};
UniversalDate.prototype.getWeek = function(oLocale, vCalendarWeekNumbering) {
  return UniversalDate.getWeekByDate(this.sCalendarType, this.getFullYear(), this.getMonth(), this.getDate(), oLocale, vCalendarWeekNumbering);
};
UniversalDate.prototype.setWeek = function(oWeek, oLocale, vCalendarWeekNumbering) {
  var oDate = UniversalDate.getFirstDateOfWeek(this.sCalendarType, oWeek.year || this.getFullYear(), oWeek.week, oLocale, vCalendarWeekNumbering);
  this.setFullYear(oDate.year, oDate.month, oDate.day);
};
UniversalDate.prototype.getUTCWeek = function(oLocale, vCalendarWeekNumbering) {
  return UniversalDate.getWeekByDate(this.sCalendarType, this.getUTCFullYear(), this.getUTCMonth(), this.getUTCDate(), oLocale, vCalendarWeekNumbering);
};
UniversalDate.prototype.setUTCWeek = function(oWeek, oLocale, vCalendarWeekNumbering) {
  var oDate = UniversalDate.getFirstDateOfWeek(this.sCalendarType, oWeek.year || this.getFullYear(), oWeek.week, oLocale, vCalendarWeekNumbering);
  this.setUTCFullYear(oDate.year, oDate.month, oDate.day);
};
UniversalDate.prototype.getQuarter = function() {
  return Math.floor(this.getMonth() / 3);
};
UniversalDate.prototype.getUTCQuarter = function() {
  return Math.floor(this.getUTCMonth() / 3);
};
UniversalDate.prototype.getDayPeriod = function() {
  if (this.getHours() < 12) {
    return 0;
  } else {
    return 1;
  }
};
UniversalDate.prototype.getUTCDayPeriod = function() {
  if (this.getUTCHours() < 12) {
    return 0;
  } else {
    return 1;
  }
};
UniversalDate.prototype.getTimezoneShort = function() {
  if (this.oDate.getTimezoneShort) {
    return this.oDate.getTimezoneShort();
  }
};
UniversalDate.prototype.getTimezoneLong = function() {
  if (this.oDate.getTimezoneLong) {
    return this.oDate.getTimezoneLong();
  }
};
var iMillisecondsInWeek = 7 * 24 * 60 * 60 * 1e3;
UniversalDate.getWeekByDate = function(sCalendarType, iYear, iMonth, iDay, oLocale, vCalendarWeekNumbering) {
  vCalendarWeekNumbering = vCalendarWeekNumbering || Configuration_default.getCalendarWeekNumbering();
  checkWeekConfig(vCalendarWeekNumbering);
  oLocale = oLocale || Configuration_default.getFormatSettings().getFormatLocale();
  var clDate = this.getClass(sCalendarType);
  var oFirstDay = getFirstDayOfFirstWeek(clDate, iYear, oLocale, vCalendarWeekNumbering);
  var oDate = new clDate(clDate.UTC(iYear, iMonth, iDay));
  var iWeek, iLastYear, iNextYear, oLastFirstDay, oNextFirstDay;
  var bSplitWeek = isSplitWeek(vCalendarWeekNumbering, oLocale);
  if (bSplitWeek) {
    iWeek = calculateWeeks(oFirstDay, oDate);
  } else {
    iLastYear = iYear - 1;
    iNextYear = iYear + 1;
    oLastFirstDay = getFirstDayOfFirstWeek(clDate, iLastYear, oLocale, vCalendarWeekNumbering);
    oNextFirstDay = getFirstDayOfFirstWeek(clDate, iNextYear, oLocale, vCalendarWeekNumbering);
    if (oDate >= oNextFirstDay) {
      iYear = iNextYear;
      iWeek = 0;
    } else if (oDate < oFirstDay) {
      iYear = iLastYear;
      iWeek = calculateWeeks(oLastFirstDay, oDate);
    } else {
      iWeek = calculateWeeks(oFirstDay, oDate);
    }
  }
  return {
    year: iYear,
    week: iWeek
  };
};
UniversalDate.getFirstDateOfWeek = function(sCalendarType, iYear, iWeek, oLocale, vCalendarWeekNumbering) {
  vCalendarWeekNumbering = vCalendarWeekNumbering || Configuration_default.getCalendarWeekNumbering();
  checkWeekConfig(vCalendarWeekNumbering);
  oLocale = oLocale || Configuration_default.getFormatSettings().getFormatLocale();
  var clDate = this.getClass(sCalendarType);
  var oFirstDay = getFirstDayOfFirstWeek(clDate, iYear, oLocale, vCalendarWeekNumbering);
  var oDate = new clDate(oFirstDay.valueOf() + iWeek * iMillisecondsInWeek);
  var bSplitWeek = isSplitWeek(vCalendarWeekNumbering, oLocale);
  if (bSplitWeek && iWeek === 0 && oFirstDay.getUTCFullYear() < iYear) {
    return {
      year: iYear,
      month: 0,
      day: 1
    };
  }
  return {
    year: oDate.getUTCFullYear(),
    month: oDate.getUTCMonth(),
    day: oDate.getUTCDate()
  };
};
function isSplitWeek(vCalendarWeekNumbering, oLocale) {
  var oLocaleData = LocaleData_default.getInstance(oLocale);
  return (vCalendarWeekNumbering === CalendarWeekNumbering_default2.Default || vCalendarWeekNumbering === CalendarWeekNumbering_default2.WesternTraditional) && oLocaleData.firstDayStartsFirstWeek();
}
function checkWeekConfig(vCalendarWeekNumbering) {
  if (typeof vCalendarWeekNumbering === "object") {
    if (typeof vCalendarWeekNumbering.firstDayOfWeek !== "number" || typeof vCalendarWeekNumbering.minimalDaysInFirstWeek !== "number") {
      throw new TypeError("Week config requires firstDayOfWeek and minimalDaysInFirstWeek to be set");
    }
  } else if (!Object.values(CalendarWeekNumbering_default2).includes(vCalendarWeekNumbering)) {
    throw new TypeError("Illegal format option calendarWeekNumbering: '" + vCalendarWeekNumbering + "'");
  }
}
function resolveCalendarWeekConfiguration(vCalendarWeekNumbering, oLocale) {
  if (typeof vCalendarWeekNumbering === "object" && typeof vCalendarWeekNumbering.firstDayOfWeek === "number" && typeof vCalendarWeekNumbering.minimalDaysInFirstWeek === "number") {
    return vCalendarWeekNumbering;
  }
  return CalendarUtils_default.getWeekConfigurationValues(vCalendarWeekNumbering, oLocale);
}
function getFirstDayOfFirstWeek(clDate, iYear, oLocale, vCalendarWeekNumbering) {
  oLocale = oLocale || Configuration_default.getFormatSettings().getFormatLocale();
  var oWeekConfig = resolveCalendarWeekConfiguration(vCalendarWeekNumbering, oLocale);
  var iMinDays = oWeekConfig.minimalDaysInFirstWeek;
  var iFirstDayOfWeek = oWeekConfig.firstDayOfWeek;
  var oFirstDay = new clDate(clDate.UTC(iYear, 0, 1));
  var iDayCount = 7;
  if (isNaN(oFirstDay.getTime())) {
    throw new Error("Could not determine the first day of the week, because the date object is invalid");
  }
  while (oFirstDay.getUTCDay() !== iFirstDayOfWeek) {
    oFirstDay.setUTCDate(oFirstDay.getUTCDate() - 1);
    iDayCount--;
  }
  if (iDayCount < iMinDays) {
    oFirstDay.setUTCDate(oFirstDay.getUTCDate() + 7);
  }
  return oFirstDay;
}
function calculateWeeks(oFromDate, oToDate) {
  return Math.floor((oToDate.valueOf() - oFromDate.valueOf()) / iMillisecondsInWeek);
}
var mEras = {};
UniversalDate.getEraByDate = function(sCalendarType, iYear, iMonth, iDay) {
  var aEras = getEras(sCalendarType), iTimestamp = (/* @__PURE__ */ new Date(0)).setUTCFullYear(iYear, iMonth, iDay), oEra;
  for (var i = aEras.length - 1; i >= 0; i--) {
    oEra = aEras[i];
    if (!oEra) {
      continue;
    }
    if (oEra._start && iTimestamp >= oEra._startInfo.timestamp) {
      return i;
    }
    if (oEra._end && iTimestamp < oEra._endInfo.timestamp) {
      return i;
    }
  }
};
UniversalDate.getCurrentEra = function(sCalendarType) {
  var oNow = UI5Date_default.getInstance();
  return this.getEraByDate(sCalendarType, oNow.getFullYear(), oNow.getMonth(), oNow.getDate());
};
UniversalDate.getEraStartDate = function(sCalendarType, iEra) {
  var aEras = getEras(sCalendarType), oEra = aEras[iEra] || aEras[0];
  if (oEra._start) {
    return oEra._startInfo;
  }
};
function getEras(sCalendarType) {
  var oLocale = Configuration_default.getFormatSettings().getFormatLocale(), oLocaleData = LocaleData_default.getInstance(oLocale), aEras = mEras[sCalendarType];
  if (!aEras) {
    var aEras = oLocaleData.getEraDates(sCalendarType);
    if (!aEras[0]) {
      aEras[0] = {
        _start: "1-1-1"
      };
    }
    for (var i = 0; i < aEras.length; i++) {
      var oEra = aEras[i];
      if (!oEra) {
        continue;
      }
      if (oEra._start) {
        oEra._startInfo = parseDateString(oEra._start);
      }
      if (oEra._end) {
        oEra._endInfo = parseDateString(oEra._end);
      }
    }
    mEras[sCalendarType] = aEras;
  }
  return aEras;
}
function parseDateString(sDateString) {
  var aParts = sDateString.split("-"), iYear, iMonth, iDay;
  if (aParts[0] == "") {
    iYear = -parseInt(aParts[1]);
    iMonth = parseInt(aParts[2]) - 1;
    iDay = parseInt(aParts[3]);
  } else {
    iYear = parseInt(aParts[0]);
    iMonth = parseInt(aParts[1]) - 1;
    iDay = parseInt(aParts[2]);
  }
  return {
    // no need to use UI5Date.getInstance as only the UTC timestamp is used
    timestamp: (/* @__PURE__ */ new Date(0)).setUTCFullYear(iYear, iMonth, iDay),
    year: iYear,
    month: iMonth,
    day: iDay
  };
}
var UniversalDate_default = UniversalDate;

export {
  getFirstDayOfWeek,
  CalendarType_default,
  getCalendarType2 as getCalendarType,
  getSecondaryCalendarType2 as getSecondaryCalendarType,
  TimezoneUtil_default,
  Configuration_default,
  Core_default,
  assert_default,
  Log_default,
  CalendarType_default2,
  CalendarType_default3,
  Localization_default,
  LanguageTag_default,
  Locale_default,
  extend_default,
  CalendarWeekNumbering_default,
  CalendarWeekNumbering_default2,
  LocaleData_default,
  Calendars_default,
  CalendarUtils_default,
  UI5Date_default,
  UniversalDate_default
};
/*! Bundled license information:

@ui5/webcomponents-localization/dist/sap/base/assert.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/base/util/isPlainObject.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/ui/base/DataType.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/base/i18n/date/CalendarType.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/ui/core/CalendarType.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/base/i18n/date/TimezoneUtils.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/ui/core/format/TimezoneUtil.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/base/util/array/uniqueSort.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/ui/base/Metadata.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/ui/base/Object.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)
  (*!oObject[sMethodName] for 'lazy' loading interface methods ;-) *)

@ui5/webcomponents-localization/dist/sap/base/i18n/LanguageTag.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/ui/core/Locale.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/base/util/_merge.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/base/util/extend.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/base/i18n/date/CalendarWeekNumbering.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/ui/core/date/CalendarWeekNumbering.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/ui/core/LocaleData.js:
  (*!
  * OpenUI5
  * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
  * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
  *)

@ui5/webcomponents-localization/dist/sap/ui/core/date/CalendarUtils.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/ui/core/date/UI5Date.js:
  (*!
   * OpenUI5
   * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
   * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
   *)

@ui5/webcomponents-localization/dist/sap/ui/core/date/UniversalDate.js:
  (*!
  * OpenUI5
  * (c) Copyright 2009-2024 SAP SE or an SAP affiliate company.
  * Licensed under the Apache License, Version 2.0 - see LICENSE.txt.
  *)
*/
//# sourceMappingURL=chunk-BWZI5OG7.js.map
